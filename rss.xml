<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>淘小僧</title>
    <link>http://42.121.114.240/</link>
    <pubDate>2013-11-03 12:19:57 +0800</pubDate>
    <item>
      <title>many tips</title>
      <link>http://42.121.114.240//2013/10/04/manytips.html</link>
      <pubDate>2013-10-04 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Tips&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;问：[centos]Can&amp;rsquo;t ssh to server with root account because of gitosis?
答：Just remove /root/.ssh/authorized_keys&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>Core Text</title>
      <link>http://42.121.114.240//2013/10/01/coretext.html</link>
      <pubDate>2013-10-01 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Core Text&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Here you need to create a path which bounds the area where you will be drawing text. Core Text on the Mac supports different shapes like rectangles and circles, but for the moment iOS supports only rectangular shape for drawing with Core Text. In this simple example, you’ll use the entire view bounds as the rectangle where you will be drawing by creating a CGPath reference from self.bounds.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>IOS开发</title>
      <link>http://42.121.114.240//2013/09/21/iosDevTip.html</link>
      <pubDate>2013-09-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;app打开默认是混合音模式
开始录音的时候如果选择的模式是playandrecord，则也能支持播放。&lt;/p&gt;

&lt;p&gt;ios7系统里跑ios6兼容模式，删除按钮的位置有变化&lt;/p&gt;
</description>
    </item>
    <item>
      <title>tips_when_install_node_modules</title>
      <link>http://42.121.114.240//2013/08/12/tips_when_install_node_modules.html</link>
      <pubDate>2013-08-12 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;安装自己的node代码及安装node_modules的注意&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;package.json里的版本号似乎需要1.0.1这种类似的格式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将你的代码打包后，你需要在其他未安装的服务器上运行时，则你可能需要临时安装你的node相关的node_module，此时你可以不要将你原来的代码里的nodemoudle带过来，而是通过npm install安装node module模块，当然最好是要求你的node module里的模块的版本和你开发测试的版本一致。否则你可能会出现异常的情况。所以注意修改设置你的package.json里的相关依赖模块的版本号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>Nodejs中的async的使用</title>
      <link>http://42.121.114.240//2013/08/12/how_to_use_async_in_nodejs.html</link>
      <pubDate>2013-08-12 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Nodejs中的async的使用&lt;/h1&gt;

&lt;p&gt;Nodejs中最最感觉不舒服的是因为全异步引起的代码层级变的更大而导致阅读更加麻烦。
所以解决因为nodejs的这个问题，我按照前人的提示选择了async的框架&lt;/p&gt;

&lt;p&gt;其实这个框架里我更多的是使用async的auto方法
因为这个方法可以并行，串行，按照我写的规则去执行一些异步方法。&lt;/p&gt;

&lt;p&gt;比如可以这样
async.auto({
     task1:function(cb, paramData){
     },
     task2:function(cb, paramData){
     },
     task3:[&amp;lsquo;task1&amp;rsquo;,&amp;lsquo;task2&amp;rsquo;,function(cb, paramData){
     }
     task4:[&amp;lsquo;task3&amp;rsquo;,function(cb, paramData){
     }
},function(err, result){
});&lt;/p&gt;

&lt;p&gt;这个流程最后跑的是task1和task2并发执行，执行完后，task3执行，然后再task4执行，最终完成后执行最下面的function函数，如果中途的cb中的参数不为null，则直接退出上面的task流程，直接执行最后的function函数。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Core Data</title>
      <link>http://42.121.114.240//2013/08/12/core_data.html</link>
      <pubDate>2013-07-11 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Core Data&lt;/h1&gt;

&lt;p&gt;1: Core Data
数据库操作当有insert操作做merge通知的时候会立即触发processPendingChange，但是如果没有insert，而只有delete和update的时候，则只会投放一个processPendingChange但不会立即执行，所以当一个save先update然后delete的时候，merge就出问题了。&lt;/p&gt;

&lt;p&gt;工作：
今天依然是对首页等地方进行性能调优
改善的点是
1：计算时间，格式化显示的时候，ios相对比较耗时，此时如果对性能有一定要求的话，还是考虑用c的api实现一把，另外stringWithFormat在对性能有一定要求的地方也应该尽量考虑用C函数拼接好后再一次搞定。
经过函数的重写，该函数性能提升2.4倍&lt;/p&gt;

&lt;p&gt;2：core data数据库fetch的时候，如果你只为了查询一个对象，而且这个对象之前已经在当前contxt上的话，那么fetch操作依然是一个耗时的操作，原因应该是由于core data没有暴露出来的key，那么你查询数据库中的条件理论上查询出来的都是一个数组，而且及时表是一个空表，core data的一次fetch依然会尝试查询数据库一把。也就造成了性能的直接下降。
但是据说如果你是用了objectid去查询的话就快一些，因为你的对象已经在内存中了，并且一个managedObject有个fault属性，如果你查询的objectId对应的对象的fault属性不是true的话，你的查询应该就不会倒数据库里在查询呢一次。&lt;/p&gt;

&lt;p&gt;3：个人感觉如果需要使用core data，应该尽可能的不要直接完全依然coredata的managedObject对象，一是可以一定程度解耦，不然一旦更换core data的机制，你就代码里也改动很大了。&lt;/p&gt;

&lt;p&gt;4：c函数里（t m） 结构体和和time_t可以通过mktime，gmtime和localtime去互相转化，注意localtime是当地时区的时间。获取的time_t都是从1970年开始到现在的时间。另外注意的是t m里tm_mon是从0开始算起的月份，所以正常情况下你需要进行+1处理表示正常的月份。
另外注意如果是考虑到多线程的话，不要使用localtime，这个是线程不安全的，应该使用localtime_r等接口。
struct tm localNow;
time_t rawtime = (time_t)offsetTimeInterval;
localtime_r(&amp;amp;rawtime, &amp;amp;localNow);
这样就填充好了一个包含年月日时分秒的数据结构了。&lt;/p&gt;

&lt;p&gt;5：网上一些关于性能调优的要点记录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在Image Views中调整图片大小
如果要在&lt;code&gt;UIImageView&lt;/code&gt;中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是&lt;code&gt;UIImageView&lt;/code&gt;嵌套在&lt;code&gt;UIScrollView&lt;/code&gt;中的情况下。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。&lt;/p&gt;

&lt;p&gt;非工作：
nodejs摸索出package.json为什么老是解析失败。。。
不知道为什么，version版本信息必须是0.0.1这种类型的，如果写成1.0则失败。。。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>more about markdown</title>
      <link>http://42.121.114.240//2013/04/06/more-about-markdown.html</link>
      <pubDate>2013-06-05 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;关于几个之前忽略的markdown的语法&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;行末连续两个空格然后回车，可以造成文本换行&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;abcdefg“空格空格”
hijklmn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;abcdefg&lt;br /&gt;
hijklmn&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a name=&#34;md-anchor&#34; id=&#34;md-anchor&#34;&gt;段落缩进&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;段落缩进演示：
&amp;gt; 第一段
&amp;gt;
&amp;gt;&amp;gt; 第二段
&amp;gt;&amp;gt;&amp;gt; 第三段
&amp;gt;&amp;gt;
&amp;gt;&amp;gt; 第二段&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四个空格缩进是代码块：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无序列表&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;星号、减号、加号开始列表。

&lt;ul&gt;
&lt;li&gt;列表层级和缩进有关。

&lt;ul&gt;
&lt;li&gt;和具体符号无关。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回一级列表。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有序列表&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数字和点开始有序列表。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注意子列表的缩进位置。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;三级列表。&lt;/li&gt;
&lt;li&gt;编号会自动更正。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二级列表，编号自动更正为2。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回一级列表。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上标、下标&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Water: H&lt;sub&gt;2&lt;/sub&gt;O&lt;/li&gt;
&lt;li&gt;E = mc&lt;sup&gt;2&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;等宽字体
行内反引号嵌入代码，如: &lt;code&gt;git status&lt;/code&gt; 。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内部跳转
&lt;a name=&#34;md-anchor&#34; id=&#34;md-anchor&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;跳转至 &lt;a href=&#34;#md-anchor&#34;&gt;文内链接&lt;/a&gt; 。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;摘抄自：&lt;a href=&#34;http://www.worldhello.net/gotgithub/appendix/markups.html&#34;&gt;链接&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>涨姿势-NSCache</title>
      <link>http://42.121.114.240//2013/05/30/about_nscache.html</link>
      <pubDate>2013-05-30 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;NSCache&lt;/h1&gt;

&lt;p&gt;他的用法很简单，基本等效于NSMutableDictionary，只不过他不保证cache里的对象永远存在，也许在低内存警告时会释放掉部分对象，所以如果你的程序里如果有可以重复创建的对象需要保存时，可以考虑使用这个类。&lt;/p&gt;

&lt;p&gt;以下是转载来的。
NSCache 是iOS4以后引入的一个方便的缓存某些object的类。它的使用方法与NSMutableDictionary很相似，但是他会在内存吃紧的时候自动释放某些object。而且不用考虑线程安全的问题。具体的可以参见官方文档的描述。以下是stackoverflow里面一个比较不错的应用例子：&lt;/p&gt;

&lt;p&gt;You use it the same way you would use NSMutableDictionary. The difference is that whenNSCache detects excessive memory pressure (i.e. it&amp;rsquo;s caching too many values) it will release some of those values to make room.&lt;/p&gt;

&lt;p&gt;If you can recreate those values at runtime (by downloading from the Internet, by doing calculations, whatever) then NSCache may suit your needs. If the data cannot be recreated (e.g. it&amp;rsquo;s user input, it is time-sensitive, etc.) then you should not store it in an NSCache because it will be destroyed there.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;You use it the same way you would use NSMutableDictionary. The difference is that whenNSCache detects excessive memory pressure (i.e. it&#39;s caching too many values) it will release some of those values to make room.

If you can recreate those values at runtime (by downloading from the Internet, by doing calculations, whatever) then NSCache may suit your needs. If the data cannot be recreated (e.g. it&#39;s user input, it is time-sensitive, etc.) then you should not store it in an NSCache because it will be destroyed there.

Example, not taking thread safety into account:

// Your cache should have a lifetime beyond the method or handful of methods
// that use it. For example, you could make it a field of your application
// delegate, or of your view controller, or something like that. Up to you.
NSCache *myCache = ...;
NSAssert(myCache != nil, @&amp;quot;cache object is missing&amp;quot;);

// Try to get the existing object out of the cache, if it&#39;s there.
Widget *myWidget = [myCache objectForKey: @&amp;quot;Important Widget&amp;quot;];
if (!myWidget) {
    // It&#39;s not in the cache yet, or has been removed. We have to
    // create it. Presumably, creation is an expensive operation,
    // which is why we cache the results. If creation is cheap, we
    // probably don&#39;t need to bother caching it. That&#39;s a design
    // decision you&#39;ll have to make yourself.
    myWidget = [[[Widget alloc] initExpensively] autorelease];

    // Put it in the cache. It will stay there as long as the OS
    // has room for it. It may be removed at any time, however,
    // at which point we&#39;ll have to create it again on next use.
    [myCache setObject: myWidget forKey: @&amp;quot;Important Widget&amp;quot;];
}

// myWidget should exist now either way. Use it here.
if (myWidget) {
    [myWidget runOrWhatever];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>git使用及github</title>
      <link>http://42.121.114.240//2013/05/30/git_useage_and_github.html</link>
      <pubDate>2013-05-30 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;git使用及github&lt;/h1&gt;

&lt;p&gt;git 和github越来越多人使用，作为一个程序员，应该懂的怎么去用，而我就是个不怎么会用的人，所以我的主管在我刚开始上班的时候就要我去熟悉git那套东西。&lt;/p&gt;

&lt;p&gt;当时我依然不是很懂，但最近开始迷糊的懂了，下面是我这段时间的心得。&lt;/p&gt;

&lt;h2&gt;创建ssh从而能免登访问github。&lt;/h2&gt;

&lt;p&gt;命令&lt;code&gt;ssh-keygen&lt;/code&gt;去创建公钥私钥，如果你只希望访问一个服务器的话，比如github，那么你就放到默认的目录下，并且使用默认的私钥和公钥文件路径，即~/.ssh/id_rsa和~/.ssh/id_rsa.pub，其中id_rsa.pub是公钥文件。我们需要将这个文件里的数据复制并粘贴到github上的ssh key里。从而通过ssh就可以面等访问github了。&lt;/p&gt;

&lt;p&gt;如果你有多个服务器需要访问，比如我们还需要访问gitlab，那么，这个时候，需要~/.ssh/config文件里的配置来区分服务器和ssh秘钥。&lt;/p&gt;

&lt;p&gt;比如我自己的配置为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host github.com
    HostName github.com
    User taoxiaoseng@gmail.com
    IdentityFile /Users/Dick/.ssh/github_taoxiaoseng_rsa
    
Host gitlab.alibaba-inc.com
    HostName gitlab.alibaba-inc.com
    User guodi.ggd@taobao.com
    IdentityFile /Users/Dick/.ssh/gitlab_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说访问github用文件github_taoxiaoseng_rsa，访问gitlab用gitlab_rsa。注意公钥也需要上传到相应的服务器里。&lt;/p&gt;

&lt;p&gt;其实还有些网上也经常说，这里不细提了。比如这些东西&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;you name&amp;quot;
git config --global user.email youremail@gmail.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;如何创建git仓库&lt;/h2&gt;

&lt;p&gt;其实每次你创建github里的仓库时，都会告诉你怎么去push，这里还是做下说明，讲我理解的说下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir helloworld            
cd helloworld
git init            创建一个空的数据仓库
touch readme.md
git add .           自动判断添加相应文件到git中
git commit -m &amp;quot;commit first file&amp;quot;           提交并且添加提交日志
git remote add origin git@github.com:TaoXiaoSeng/test.git 这个最关键，说的是在本地git中添加remote的git地址，并且以origin命名，这样以后我们就不需要每次都写git地址了。实际上他在.git目录里的config添加了一条记录，类似这样的。注意我这里特意加了两个，地址不一样。注意github区分大小写的仓库路径（我的用户名有大小写，如果不完全匹配则认为访问不到了。）。另外注意这里的branch，当你init的时候默认创建的就是master。
            [remote &amp;quot;origin&amp;quot;]
                url = git@github.com:taoxiaoseng/test.git
                fetch = +refs/heads/*:refs/remotes/origin/*
            [remote &amp;quot;remote&amp;quot;]
                url = git@github.com:TaoXiaoSeng/test.git
                fetch = +refs/heads/*:refs/remotes/remote/*git 
            [branch &amp;quot;master&amp;quot;]
                remote = remote
                merge = refs/heads/master
git push -u origin master           向远程origin对应的仓库里push本地master分支。这里用-u是类似使用upstream的意思?
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;其他git命令&lt;/h2&gt;

&lt;p&gt;git branch      罗列所有分支
git branch branchname   创建分支
git checkout branchname     切换分支
git branch -d branchname    假删除分支，如果是分支是当前正在运行的分支，则删除失败
git branch -D branchname    真删除分支&lt;/p&gt;

&lt;p&gt;git ls-remote       查看远程版本库中的分支情况
git push remote :branchname     远程删除分支，注意如果分支是默认分支，则删除失败&lt;/p&gt;

&lt;h2&gt;里程碑管理&lt;/h2&gt;

&lt;p&gt;里程碑及tag，和分支管理类似，保存在.git/refs/tags路径下，引用可能指向一个提交，但也可能是其他类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;轻量级里程碑：用git tag &lt;tagname&gt; [&lt;commit&gt;]命令创建，引用直接指向一个提交对象&lt;commit&gt;&lt;/li&gt;
&lt;li&gt;带说明的里程碑：用git tag -a &lt;tagname&gt; [&lt;commit&gt;] 命令创建，并且在创建时需要提供创建里程碑的说明。Git会创建一个tag对象保存里程碑说明、里程碑的指向、创建里程碑的用户等信息，里程碑引用指向该Tag对象。&lt;/li&gt;
&lt;li&gt;带签名的里程碑：用git tag -s &lt;tagname&gt; [&lt;commit&gt;] 命令创建。是在带说明的里程碑的基础上引入了PGP签名，保证了所创建的里程碑的完整性和不可拒绝性。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>CoreData编程指南_CoreData的并发编程_章节翻译</title>
      <link>http://42.121.114.240//2013/04/22/Concurrency_with_Core_Data.html</link>
      <pubDate>2013-04-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Core Data的并发（Concurrency with Core Data）&lt;/h1&gt;

&lt;p&gt;存在着一些的场景，我们需要利用后台线程或者队列来执行Core Data的一些操作，因为他们能我们带来一些好处，尤其是你需要在Core Data在做一些比较消耗时间的任务时能保证应用程序的用户交互界面能及时响应。但是如果你并发使用Core Data时，那么你需要关心，考虑到对象图(object Groups)不会进入一个冲突的状态。&lt;/p&gt;

&lt;p&gt;如果你选择使用并发编程来操作Core Data，你还需要考虑到应用程序的环境。对于大多数的情况，AppKit和UIKit是线程不安全的；另外，OS X Cocoa bindings和controllers也都是线程不安全的 &amp;ndash; 如果你正在使用这些技术，多线程就会复杂了。&lt;/p&gt;

&lt;h2&gt;使用Thread Confinement来支持并发（Use Thread Confinement to Support Concurrency）&lt;/h2&gt;

&lt;p&gt;Core Data推荐的并发编程的模式是thread confinement（线程封闭，线程约束？）：每个线程必须拥有属于它自身的，完全私有的managed object context。&lt;/p&gt;

&lt;p&gt;这里有两种可能的方法来采用这种模式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;给每个线程创建一个managed object context，并且共享一个persistent store coordinator&lt;/li&gt;
&lt;li&gt;给每隔线程创建一个managed object context和persistent store coordinator。（这种方法提供更加强大的并发，但是同样会更加的复杂（尤其是你需要在不同的context之间进行交互）和消耗更多的内存使用）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你必须在它使用的线程中创建相应的managed context。如果你使用的NSOperation，你需要注意它的init方法是在被调用（caller）的线程里执行的。所以你不能够在queue的init方法里创建managed object context，否则你创建的context会关联到这个caller调用者的线程。与之相对应的，你应该在main方法（针对serial queue串行队列）或者start方法（针对concurent queue并发队列）里创建context。&lt;/p&gt;

&lt;p&gt;使用thread confinement（线程封闭，线程约束？），你不应该在线程间传递managed objects或者managed object contexts。如果你需要跨线程传递一个managed object，你可以通过以下方法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传递它的object ID（objectID）然后在接收线程里的managed object context里使用objectWithID:或者existingObjectWithID:error:去获取。相对应的managed objects必须已经保存（save）&amp;ndash;你不能够传递一个新创建的还没有保存过的managed object的ID给另外一个context上。&lt;/li&gt;
&lt;li&gt;在接收context上通过执行fetch来获取得到需要的managed object。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些方法会在接收context上创建一个本地版本（local version）的managed object。&lt;/p&gt;

&lt;p&gt;你能够通过NSFetchRequest的相关方法来更加方便高效的跨平台去操作数据。例如一个配置一个fetch请求来返回一些列的object IDs，当然也可以包括row data（同时更新cache的row数据）&amp;ndash; 这对于你想在一个后台线程里传递一些object IDs到另外的线程里是很有用的。&lt;/p&gt;

&lt;p&gt;通常情况下你没有必要去lock managed objects或者managed object contexts。然后，如果你使用单一的被多个context共享的persistent store coordinator，并且想要在它上面执行一些操作（比如你想要添加一个新的store），或者你想要集合多个operation像一个事务一样一起在one context执行。你应该lock锁住persistent store coordinator。&lt;/p&gt;

&lt;h2&gt;在其他线程里使用notification通知来跟踪变动&lt;/h2&gt;

&lt;p&gt;你在一个context上对一个managed object的改动是不能自动的通知传播到另外一个不同的context上相关联对应的managed object，除非你主动重新查询（refetch）或者&lt;strong&gt;&lt;em&gt;re-fault(?)&lt;/em&gt;&lt;/strong&gt;这个object。如果你需要在某个线程上跟踪另外一个线程上的改动，这里有两种方法达到这个目的，两个都是通过notifications通知的方式。为了能更好的解释说明的目的，我们现在假设有两个线程A和B，假设你现在想要将B上的改动传送通知给A。&lt;/p&gt;

&lt;p&gt;一般来说，你在线程A上注册managed object context的save通知，NSManagedObjectContextDidSaveNotification。当你接收到这个通知的时候，这个通知里的userinfo（dictionary类型）包含了在B线程里被插入，删除，更新的managed objects的数组信息。由于这些managed objects是被关联到不同的线程上，因此你不应该直接去访问这些对象。与之对应的，你应该将notification作为的一个参数来传递给&lt;a href=&#34;http://developer.apple.com/library/ios/#documentation/cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/NSManagedObjectContext.html#//apple_ref/occ/instm/NSManagedObjectContext/mergeChangesFromContextDidSaveNotification:&#34;&gt;mergeChangesFromContextDidSaveNotification:&lt;/a&gt;方法（这个方法是你在用来发送相关数据给线程A）。通过使用这个方法，context才能够更加安全的合并改动。&lt;/p&gt;

&lt;p&gt;注意变动的通知（change notification）是发送到NSManagedObjectContext的&lt;a href=&#34;http://developer.apple.com/library/ios/#documentation/cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/NSManagedObjectContext.html#//apple_ref/occ/instm/NSManagedObjectContext/processPendingChanges&#34;&gt;processPendingChanges&lt;/a&gt;方法。这个方法在主线程是被绑定到应用程序的事件循环里的，这样在主线程上，processPendingChanges就能让用户在context上的每个用户事件后被自动调用。但这不适用于后台进程 &amp;ndash; 什么时候这个方法被调用是决定于平台（platform）和发布版本（release version），所以你不应该依赖与特定的时间。如果第二个context不是在主线程上，你应该自己在适当时刻来调用processPendingChanges方法。（你应该创建你自己概念上的后台线程上工作“循环”（周期？cycle） &amp;ndash; 比如在一系列的操作之后）。&lt;/p&gt;

&lt;h2&gt;后台查询来支持UI响应（Fetch in the Background for UI Responsiveness）&lt;/h2&gt;

&lt;p&gt;executeFetchRequest:error:方法本质上会根据硬件和工作负载来对它的行为进行一定调整。如果需要，Core Data将会创建额外的私有线程来优化查询性能。你不需要为了优化提高查询的速度的目的而特意的为此创建后台线程。当然这仍然有可能被适当使用，不管怎么说，通过后台线程或queue去查询来尽量避免你的应用程序被用户交互阻塞住。这意味着，如果一个查询很复杂，或者会返回大量的数据，那么你能通过这样的方式来控制，等到这些数据获取到的时候再展示出这些数据。&lt;/p&gt;

&lt;p&gt;为了遵从thread confinement（线程封闭？线程约束？）的设计模式，你使用两个managed object context来关联到一个persistent store coordinator。你从一个后台线程的managed object context上来查询数据，然后传递相应的查询得到的object IDs到另外一个线程里。在第二个线程里（一般来说指的是应用程序的主线程，因为你可以得到这些数据后将他们在这个线程里展示出来），你用第二个context来fault这些传递过来的objectIDs对应的那些objects（你可以使用objectWithID:来实例化这些对象）。（这项技术仅仅对于你使用SQLite store的时候才有效，因为binary和xml stores的存储介质里的数据会在被打开的时候就都被读取到内存里了）&lt;/p&gt;

&lt;h2&gt;在后台线程做保存操作是容易出错的（Saving in a Background Thread is Error-prone）&lt;/h2&gt;

&lt;p&gt;异步的队列和线程都不会阻止应用程序被关闭，也就是说应用程序是不会等异步线程的退出结束之后才关闭。（具体点说就是，所有的NSThread-based线程都是“detached”（独立的？分离的？附加的？）&amp;ndash; 更加详细的可以查看pthread的文档 &amp;ndash; 而一个进程只会等到所有的not-detached线程退出后才退出）如果你在一个后台线程里执行一个保存操作，那么，这个操作可能在它完成保存操作前被杀死。如果你需要在一个后台线程里做保存操作，你必须写一些额外的代码，类似让主线程阻止应用程序在所有的保存操作完成前退出。&lt;/p&gt;

&lt;h2&gt;如果你不用Thread Confinement（If You Don’t Use Thread Containment）&lt;/h2&gt;

&lt;p&gt;如果你选线不使用程兼容的模式 &amp;ndash; 这就是说，如果你尝试在多线程间传递managed objects或者contexts等类似的操作 &amp;ndash; 你就必须非常消息的去锁数据（locking），这样的后果就是你可能失去了使用多线程带来的好处。你还需要关注一下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每次你使用相关联的managed object context去操作或者访问managed objects。Core Data没有提供一个读安全（save）但是修改有危险（dangerous）的解决方案 &amp;ndash; 而是任何操作都是危险（dangerous）的，因为任何操作都会有为了性能考虑的缓存，都可以触发faulting。&lt;/li&gt;
&lt;li&gt;managed objects自身就不是线程安全的。如果你想要跨线程去操作一个managed object，你必须锁住（lock）他的context（参考查看&lt;a href=&#34;http://developer.apple.com/library/ios/documentation/cocoa/Reference/Foundation/Protocols/NSLocking_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSLocking&#34;&gt;NSLocking&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你在多线程间共享一个managed object context或者一个persistent store coordinator，你必须确保任何被调用的方法都是以线程安全的定义的。如果需要locking，你应该使用NSLocking方法来锁住managed object context和persistent store coordinator，而不是用你自己定义的mutexes（互斥方法）。这些NSLocking方法还帮助提供了上下文的信息给应用程序的框架 &amp;ndash; 换句话说，就是除了提供了mutex互斥的目的，它（NSLocking）还帮助定义了一系列Core Data操作的上下文的工作环境。&lt;/p&gt;

&lt;p&gt;一般来说，你可以使用tryLock或者lock来锁context或者coordinator。如果你这样做了，那么框架就会保证在这之后的操作也都是线程安全。比如说，如果你为每个线程创建了一个context，但是所有的context都是指向同一个persistent store coordinator，那么Core Data会以线程安全的方式来负责访问coordinator（NSManagedObjectContext的&lt;a href=&#34;http://developer.apple.com/library/ios/#documentation/cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/NSManagedObjectContext.html#//apple_ref/occ/instm/NSManagedObjectContext/lock&#34;&gt;lock&lt;/a&gt;和unlock方法支持递归））&lt;/p&gt;

&lt;p&gt;如果你使用lock锁住了一个context（或者使用tryLock成功锁住），那么直到你调用unlock去解锁为止，你必须保持对这个context的强引用。如果你不保持强引用的话，那么在一个多线程的环境里，你可能导致死锁。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>关于CoreData中删除消息崩溃的教训</title>
      <link>http://42.121.114.240//2013/04/10/%E5%85%B3%E4%BA%8Ecoredata%E4%B8%AD%E5%88%A0%E9%99%A4%E6%B6%88%E6%81%AF%E5%B4%A9%E6%BA%83%E7%9A%84%E6%95%99%E8%AE%AD.html</link>
      <pubDate>2013-04-10 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;关于CoreData中删除记录导致崩溃的教训&lt;/h1&gt;

&lt;p&gt;由于之前没有深刻的使用过CoreData（虽然这个技术出来好多年了），只是简单的写了点demo学了下大概如何使用，以及看了一些说明简单了解了整个流程。但是由于项目需要深度使用（至少在我看来CoreData能很好降低耦合），所以工作中还是不得不碰到一些问题。比如这次就碰到。。。&lt;/p&gt;

&lt;h2&gt;前因&lt;/h2&gt;

&lt;p&gt;因为项目组需要提供SDK给外部使用，所以在做重构，而且做的调整很大很大，由于时间紧张，可能大家都是优先完成代码函数的重构，然后估摸着也很少对重构后的代码功能做测试，只是简单编译了下，然后简单的跑了下程序，看主要聊天功能没问题，就直接check in了。。。引起的后果是代码里可能有一些隐藏的bug。&lt;/p&gt;

&lt;p&gt;我因为要修改session和message等很多DB相关的代码重写（虽然对CoreData了解不是那么深，但是根据封装好的接口去重写函数还是没什么大的关系的），所以必然涉及到很多创建会话，删除会话，删除消息，插入消息的功能。重构了部分功能代码后，测试过程中发现删除message，甚至到后面删除session（因为删除session内部涉及到了删除message）都会出现数据库保存操作时错误导致后面崩溃。&lt;/p&gt;

&lt;h2&gt;现象&lt;/h2&gt;

&lt;p&gt;当有单人聊天时，如果会话中含有消息，那么只删除一条消息也会导致崩溃，清空会话的消息也崩溃。
跟踪代码后，总是死在coredata save的时候出错。导致后面跟踪到错误，主动报错崩溃。&lt;/p&gt;

&lt;h2&gt;查bug过程&lt;/h2&gt;

&lt;p&gt;多次比对了自己修改前后的代码逻辑，也查看了之前修改前的版本也存在此问题，感觉不应该是我的代码引起的，所以开始往前翻svn log记录，慢慢的找到一个同事merge了一个比较大的功能进来，并且修改比较大，改动了数据库表信息。所以关注的点开始转向数据表，前前后后花了好几个小时，也添加删除了一些代码去测试，最终还是没有找到真正的原因。这个时候觉得还是要回去翻翻官方文档比较靠谱，因为一下子也不知道到底是哪块出问题，也不知道直接找哪块比较靠谱点。晚上回来后开始翻翻core data programming guide，最后找到了一段关于Relationship Delete Rules的。这里摘抄如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Relationship Delete Rules
A relationship&#39;s delete rule specifies what should happen if an attempt is made to delete the source object. Note the phrasing in the previous sentence—&amp;quot;if an attempt is made...&amp;quot;. If a relationship&#39;s delete rule is set to Deny, it is possible that the source object will not be deleted. Consider again a department&#39;s employees relationship, and the effect that the different delete rules have.
Deny
If there is at least one object at the relationship destination, then the source object cannot be deleted.
For example, if you want to remove a department, you must ensure that all the employees in that department are first transferred elsewhere (or fired!) otherwise the department cannot be deleted.
Nullify
Set the inverse relationship for objects at the destination to null.
For example, if you delete a department, set the department for all the current members to null. This only makes sense if the department relationship for an employee is optional, or if you ensure that you set a new department for each of the employees before the next save operation.
Cascade
Delete the objects at the destination of the relationship.
For example, if you delete a department, fire all the employees in that department at the same time.
No Action
Do nothing to the object at the destination of the relationship.
For example, if you delete a department, leave all the employees as they are, even if they still believe they belong to that department.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deny：要求只要destination relationship有一个没有删除，那么source object就不能被删除。&lt;/p&gt;

&lt;p&gt;nullify：但我们的表里不是用这个规则，用的是下面的nullify。这里很明确的说明了Set the inverse relationship for objects at the destination to null（我的理解是当你删除一个对象A时，那么他的relationship对象的指向A的relationship值会被设置为null）。&lt;/p&gt;

&lt;p&gt;Cascade：级联删除，这个就不多说了&lt;/p&gt;

&lt;p&gt;No Action: 删除A，不影响B对A的relationship，B中的relationship原来是什么值就还是什么值。&lt;/p&gt;

&lt;p&gt;他给的example非常的明白。一个部门里有好多employee，所以一个部门和employee的关系是一对多的relationship，同时一个employee和部门的关系是一对一的relationship（架设一对一，当然一对多也可能），那么当你要删除一个部门的对象是，那么那个employee就没有部门了，那么&lt;strong&gt;&lt;em&gt;他与部门的relationship就要设置为null&lt;/em&gt;&lt;/strong&gt;或者你给他再找个新部门设置进去。如果你不给他找新部门，这就要求employee对部门的relationship的属性是optional，也就是说employee可以对部门的relationship值为null。&lt;/p&gt;

&lt;p&gt;理解了这个之后，再看了看数据表中关于message对session的optional关系，确实没有设置为optional.修改后，编译运行，测试通过。到此终于解决了这个问题。&lt;/p&gt;

&lt;p&gt;看样子回头还是要好好的看下coredata官方文档，否则一些细节出问题，真的很不好查找。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何在XCode中以不同的颜色分级显示不同级别的log信息</title>
      <link>http://42.121.114.240//2013/04/08/XCode%E5%88%86%E7%BA%A7%E6%98%BE%E7%A4%BAlog%E4%BF%A1%E6%81%AF.html</link>
      <pubDate>2013-04-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;转发：
原文出处：http://maxwin.me/blog/?p=124&lt;/p&gt;

&lt;h2&gt;安装：&lt;/h2&gt;

&lt;p&gt;XLog – Xcode log分级显示插件&lt;/p&gt;

&lt;p&gt;下载链接http://maxwin.me/blog/wp-content/uploads/&lt;sup&gt;2012&lt;/sup&gt;&amp;frasl;&lt;sub&gt;05&lt;/sub&gt;/XLog.zip
提供功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;支持log分级，Debug/Info/Warn/Error&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持自定义log颜色&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装可查看readme文件，其实就是./install.sh将插件XLog.bundle复制到~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/目录下&lt;/p&gt;

&lt;h2&gt;使用&lt;/h2&gt;

&lt;p&gt;引入工程中的XLogUtil.h和.m文件,也可看下列代码.
调用类似这样的代码XLog_v(@&amp;ldquo;start!&amp;rdquo;);即可。（仔细查看.h文件，里面还提供其他的分级方法，如XLog_i更多的自己查看）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
//  XLog.h
//  TestMXLog
//
//  Created by WenDong Zhang on 5/9/12.
//  Copyright (c) 2012 __MyCompanyName__. All rights reserved.
//
#import &amp;lt;Foundation/Foundation.h&amp;gt;

#define XLOG_ESC_CH @&amp;quot;\033&amp;quot;
#define XLOG_LEVEL_DEBUG    @&amp;quot;DEBUG&amp;quot;
#define XLOG_LEVEL_INFO     @&amp;quot;INFO&amp;quot;
#define XLOG_LEVEL_WARN     @&amp;quot;WARN&amp;quot;
#define XLOG_LEVEL_ERROR    @&amp;quot;ERROR&amp;quot;

// colors for log level, change it as your wish
#define XLOG_COLOR_RED   XLOG_ESC_CH @&amp;quot;#FF0000&amp;quot;
#define XLOG_COLOR_GREEN XLOG_ESC_CH @&amp;quot;#00FF00&amp;quot;
#define XLOG_COLOR_BROWN  XLOG_ESC_CH @&amp;quot;#FFFF00&amp;quot;
// hard code, use 00000m for reset flag
#define XLOG_COLOR_RESET XLOG_ESC_CH @&amp;quot;#00000m&amp;quot;   


#if defined (__cplusplus)
extern &amp;quot;C&amp;quot; {
#endif

    void _XLog_print(NSString *tag, NSString *colorStr, const char *fileName, const char *funcName, unsigned line, NSString *log);
    
    void _XLog_getFileName(const char *path, char *name);
    
    BOOL _XLog_isEnable();

#if defined (__cplusplus)
}
#endif

#define XLog_log(tag, color, ...) _XLog_print(tag, color, __FILE__, __FUNCTION__, __LINE__, [NSString stringWithFormat:__VA_ARGS__])
#define XLog_d(...) XLog_log(XLOG_LEVEL_DEBUG, XLOG_COLOR_GREEN, __VA_ARGS__)
#define XLog_i(...) XLog_log(XLOG_LEVEL_INFO, XLOG_COLOR_RESET, __VA_ARGS__)
#define XLog_v(...) XLog_log(XLOG_LEVEL_WARN, XLOG_COLOR_BROWN, __VA_ARGS__)
#define XLog_e(...) XLog_log(XLOG_LEVEL_ERROR, XLOG_COLOR_RED, __VA_ARGS__)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//
//  XLog.m
//  TestMXLog
//
//  Created by WenDong Zhang on 5/9/12.
//  Copyright (c) 2012 __MyCompanyName__. All rights reserved.
//

#import &amp;quot;XLogUtil.h&amp;quot;

//static int isXLogEnable = -1;   // -1: not set, 0: disable, 1: enable

void _XLog_print(NSString *tag, NSString *colorStr, const char *fileName, const char *funcName, unsigned line, NSString *log)
{
    const char *tagStr = [tag UTF8String];
    // show filename without path
    char *file = (char *)malloc(sizeof(char) * strlen(fileName));
    _XLog_getFileName(fileName, file);
    
    if (_XLog_isEnable()) {
        printf(&amp;quot;%s&amp;quot;, [colorStr UTF8String]);    // log color
        printf(&amp;quot;%s[%s]&amp;quot;, [XLOG_ESC_CH UTF8String], tagStr); // start tag
    }
    
    printf(&amp;quot;%s &amp;quot;, [[[NSDate date] description] UTF8String]);   // time
    printf(&amp;quot;%s %s:l%u) &amp;quot;, file, funcName, line);    // fileName
    printf(&amp;quot;%s&amp;quot;, [log UTF8String]);    // log 
    
    if (_XLog_isEnable()) {
        printf(&amp;quot;%s[/%s]&amp;quot;, [XLOG_ESC_CH UTF8String], tagStr);    // end tag
        printf(&amp;quot;%s&amp;quot;, [XLOG_COLOR_RESET UTF8String]);    // reset color
    }
    printf(&amp;quot;\n&amp;quot;);
    
    free(file);
}

BOOL _XLog_isEnable()
{
    return YES;
//    if (isXLogEnable == -1) {   // init
//        char *xlogEnv = getenv(&amp;quot;XLOG_FLAG&amp;quot;);
//        if (xlogEnv &amp;amp;&amp;amp; !strcmp(xlogEnv, &amp;quot;YES&amp;quot;)) {
//            isXLogEnable = 1;
//        } else {
//            isXLogEnable = 0;
//        }
//    }
//
//    if (isXLogEnable == 0) {
//        return NO;
//    }
//    return YES;
}

void _XLog_getFileName(const char *path, char *name)
{
    int l = strlen(path);
    while (l-- &amp;gt;= 0 &amp;amp;&amp;amp; path[l] != &#39;/&#39;) {}
    strcpy(name, path + (l &amp;gt;= 0 ? l + 1 : 0));
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>关于如何使用appledoc生成XCode能读取的文档的命令</title>
      <link>http://42.121.114.240//2013/04/06/create-docset-used-by-xcode-the-tool-appledoc.html</link>
      <pubDate>2013-04-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;messenger文档生成命令&lt;/p&gt;

&lt;p&gt;appledoc &amp;ndash;project-name WXMessengerDoc &amp;ndash;project-company &amp;ldquo;alibaba-inc&amp;rdquo; &amp;ndash;company-id com.alibaba-inc.WXMessenger &amp;ndash;output ./WXMessengerDoc &amp;ndash;ignore ./Three20 &amp;ndash;ignore ./ASIHttpRequest &amp;ndash;ignore ./script &amp;ndash;ignore ./tools &amp;ndash;ignore ./docs &amp;ndash;ignore ./Messenger/JSON &amp;ndash;ignore ./Messenger/JSONKit.h &amp;ndash;ignore ./Messenger/JSONKit.m &amp;ndash;ignore ./Messenger/PopverView &amp;ndash;ignore ./Messenger/RichText &amp;ndash;ignore /Messenger/SDWebData &amp;ndash;ignore ./Messenger/SFHFKeychainUtils &amp;ndash;ignore ./Messenger/TouchJSON &amp;ndash;ignore ./Messenger/weak_ref &amp;ndash;ignore ./Messenger/zh-Hans.lproj &amp;ndash;ignore ./Messenger/Frameworks .&lt;/p&gt;
</description>
    </item>
    <item>
      <title>关于如何使用appledoc生成XCode能读取的文档的完整版</title>
      <link>http://42.121.114.240//2013/04/06/create-docset-used-by-xcode-the-tool-appledoc[V1.0].html</link>
      <pubDate>2013-04-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;#关于生成文档的事项&lt;/p&gt;

&lt;p&gt;可以借助appledoc去生成文档，并且可以通过xcode自带的文档查看器去跳转查看。&lt;/p&gt;

&lt;p&gt;##安装步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装appledoc，简单的方法就是&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;）下载源码 git clone git://github.com/tomaz/appledoc.git&lt;/li&gt;

&lt;li&gt;&lt;p&gt;）安装appledoc，并且安装到/usr/bin等目录下，以便直接appledoc直接运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo sh install-appledoc.sh -b /usr/bin -t ~/Library/Application\ Support/appledoc
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##生成文档
通过下面的命令去生成文档
&lt;code&gt;
appledoc --project-name WXMessengerDoc --project-company &amp;quot;alibaba-inc&amp;quot; --company-id com.alibaba-inc.WXMessenger [--output ./helloworld]  [includeFilePathOrFile] [--ignore excludeFilePathOrFile] .
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个命令只扫描当前目录下所有文件（另外包含includeFilePathOrFile和去除excludeFilePathOrFile) 并生成到某个目录下(默认是当前目录）&lt;/p&gt;

&lt;p&gt;该命令结束后会添加到系统的文档目录下&lt;/p&gt;

&lt;p&gt;If the path is directory, it&amp;rsquo;s recursively parsed for all source files. If path is file, it&amp;rsquo;s parsed as source file&lt;/p&gt;

&lt;p&gt;#####更多关于命令的说明是这样的:
&lt;a href=&#34;http://gentlebytes.com/appledoc-docs-examples-basic/&#34;&gt;http://gentlebytes.com/appledoc-docs-examples-basic/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2：写代码的时候注意添加注释，我测试下生成的规则后对注释的理解。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;头文件中注释使用
/*
 我随便写的，反正这里不会被抽取作为文档的一部分，这里随便写点帮助别人如何使用该API的注释就好了，反正安装了docset后，你都可以直接option+左键点出文档相关了，这里说太多参数，函数作用，返回值的东西也没什么用，而且还占地方
 */
- (id)initWithAvatar:(UIImage *)avatarImage;


.m或者.mm文件里添加注释如果下，该部分会被appledoc提取生成文档
/** 你可以从这开始，不过也没什么必要，反正这里和下面那行一样的功能,这行不写可能更加好看点
 这里很特别，这里是添加Discussion的地方，这样我们可以看到这个函数有什么问题啊，注意事项啊，反正他放到了文档里的Discussion里，你自己看着办
 @brief 麻烦告诉我这个函数干什么用的
 @param avatarImage 介绍下avatarImage是什么东西吧。
 @return 这里是返回结果的描述，什么情况返回什么样的结果啊？
 @exception name description
 */
- (id)initWithAvatar:(UIImage *)avatarImage{
    。。。
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的方式是头文件和.m文件分开注释
但是对于protocol来说，没有实现文件了，所以还是需要直接添加注释的，这里测试的代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 这个协议的描述
 */
@protocol PHAvatarViewDelegate &amp;lt;NSObject&amp;gt;
@optional
/**
 @brief 这个didShowAvatar delegate的作用
 */
-(void)didShowAvatar:(NSString*)avatarName animated:(BOOL)animated;
@required
/**
 @brief willShowAvatar delegate的作用
 */
-(void)willShowAvatar:(NSString*)avatarName animated:(BOOL)animated;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的方式就能生成如下的效果了(protocol类似，这里不贴了），详细的注释和文档效果图见最下面&lt;/p&gt;

&lt;p&gt;##说明&lt;/p&gt;

&lt;p&gt;这里有几点说明下：（下面说的文档注释指会被提取出生成文档的，普通注释不会被提取)&lt;/p&gt;

&lt;p&gt;1:如果文档注释写到.m等文件里也是可行的，这样可以减少头文件的注释大小，头文件只添加一部分普通注释就好了。但是protocol之类的就不得不在声明处添加文档注释了。&lt;/p&gt;

&lt;p&gt;2：如果在.m .mm等文件里添加文档注释，那么生成的文档可能有个比较怪异，比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Declared In
    PHAvatarView.m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以这个是写在.m文件里的弊端。&lt;/p&gt;

&lt;p&gt;3：要生成文档的添加注释的规则方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1）多行注释是从下面这种样式/**注释*/注释里抓的，注意前面需要是/**（实际上/*!也支持），对于/*注释*/这样的注释是不会被提取的。单行注释通过///去抓取，//是不会抓取的
    /**
      注释
      */
2）简介需要标签@brief，而discussion一定要写在最前面。
3）对于同一个方法不能出现两个两个地方的文档注释，否则.h文件里的注释会覆盖了.m文件
4）扫描生成注释的时候可以忽略某些文件夹或者某些类型文件。
5）标签的格式一般为类似@param &amp;lt;name&amp;gt; &amp;lt;description&amp;gt;
6）可以通过///@name spcename去添加一段需要在文档中标示一组方法的作用，具体看下面的文档效果。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;集成安装到XCode中直接安装&lt;/h2&gt;

&lt;p&gt;还可以通过在xcode工程里添加一个target来运行该target生成文档
创建一个target，添加一个run script
内容类似下面
&lt;code&gt;
/usr/bin/appledoc \
--project-name &amp;quot;Messenger&amp;quot; \
--project-company &amp;quot;Gentle Bytes&amp;quot; \
--company-id com.alibaba-inc.WXMessenger \
--ignore UnitTest   \
.
exit 0
&lt;/code&gt;
说明：这里之前安装appledoc是安装到了/usr/bin下，运行该target后自动生成相关的文档并安装到系统文档目录（/Users/youUserName/Library/Developer/Shared/Documentation/DocSets）下。
####参见：
&lt;a href=&#34;http://www.infinite-loop.dk/wp/wp-content/uploads/2011/06/Build-Documentation-Script.png&#34;&gt;http://www.infinite-loop.dk/wp/wp-content/uploads/2011/06/Build-Documentation-Script.png&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#附：
##参考资料：
###更多参考
&lt;a href=&#34;http://gentlebytes.com/appledoc&#34;&gt;http://gentlebytes.com/appledoc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;github地址: &lt;a href=&#34;https://github.com/tomaz/appledoc&#34;&gt;https://github.com/tomaz/appledoc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.infinite-loop.dk/blog/2011/06/providing-custom-documentation-in-xcode/&#34;&gt;http://www.infinite-loop.dk/blog/2011/06/providing-custom-documentation-in-xcode/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是官方的appledoc源码和生成的文档，可以参考比对。
&lt;a href=&#34;https://github.com/tomaz/appledoc/blob/master/&#34;&gt;https://github.com/tomaz/appledoc/blob/master/&lt;/a&gt;
&lt;a href=&#34;http://gentlebytes.com/media/appledoc/examples/v2/latest/Classes/GBGenerator.html#tasks&#34;&gt;http://gentlebytes.com/media/appledoc/examples/v2/latest/Classes/GBGenerator.html#tasks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###附头文件和实现文件的注释和最后的文档效果：&lt;/p&gt;

&lt;p&gt;###&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-头文件&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** 
 这个类的作用
 */
@interface PHAvatarView : UIView
{
    
}

///-----------------------------------------------------------------
/// @name Initialization 
///-----------------------------------------------------------------


/*
 * 我随便写的，反正这里不会被抽取作为文档的一部分，这里随便写点帮助别人如何使用该API的注释就好了，反正安装了docset后，你都可以直接option+左键点出文档相关了，这里说太多参数，函数作用，返回值的东西也没什么用，而且还占地方
 *
 *
 */
//我随便写，这里不会被提取
- (id)initWithAvatar:(UIImage *)avatarImage;

@end

/**
 这个协议的描述
 */
@protocol PHAvatarViewDelegate &amp;lt;NSObject&amp;gt;
@optional
/**
 @brief 这个didShowAvatar delegate的作用
 */
-(void)didShowAvatar:(NSString*)avatarName animated:(BOOL)animated;
@required
/**
 @brief willShowAvatar delegate的作用
 */
-(void)willShowAvatar:(NSString*)avatarName animated:(BOOL)animated;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;    实现文件    &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@implementation PHAvatarView

/** 你可以从这开始，不过也没什么必要，反正这里和下面那行一样的功能,这行不写可能更加好看点
 这里很特别，这里是添加Discussion的地方，这样我们可以看到这个函数有什么问题啊，注意事项啊，反正他放到了文档里的Discussion里，你自己看着办
 @brief 麻烦告诉我这个函数干什么用的
 @param avatarImage 介绍下avatarImage是什么东西吧
 @return 这里是返回结果的描述，什么情况返回什么样的结果啊？
 @exception aaa 异常提示
 */
- (id)initWithAvatar:(UIImage *)avatarImage{
    if (self = [super initWithFrame:CGRectMake(0, 0, 50, 50)]) {
        UIImageView *avatarImageView = [[[UIImageView alloc] initWithImage:avatarImage] autorelease];
        [avatarImageView sizeToFit];
        avatarImageView.layer.cornerRadius = avatarImage.size.width/2.0;
        avatarImageView.clipsToBounds = YES;
        avatarImageView.frame = CGRectMake(2, 0, avatarImageView.frame.size.width, avatarImageView.frame.size.height);
        [self addSubview:avatarImageView];

        UIImageView *maskView = [[[UIImageView alloc] initWithImage:[UIImage imageNamed:@&amp;quot;invites-user-avatar-edge.png&amp;quot;]] autorelease];
        [maskView sizeToFit];
        [self addSubview:maskView];
    }
    return self;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;     文档效果     &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
&lt;img src=&#34;http://yunpan.alibaba-inc.com/share/scan.do?info=8H2tK3INh&amp;pInfo=8H2tK3INh&amp;app_name=&#34;&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>你的第一篇博客</title>
      <link>http://42.121.114.240//2013/first-page.html</link>
      <pubDate>2012-04-05 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢你使用Gor编写博客&lt;/h1&gt;

&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任何删掉,修改这个文件&lt;/h2&gt;

&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;
&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;
&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;
&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;

&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;gor post 文章标题
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;gor compile #编译
gor http
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;

&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;

&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;

&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;申请github帐户&lt;/li&gt;
&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;
&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;
&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git
git add -A
git commit -m &amp;quot;...&amp;quot;
git pull
git push
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;

&lt;h1&gt;祝你使用愉快&lt;/h1&gt;
</description>
    </item>
    <item>
      <title>FTP协议完全详解</title>
      <link>http://42.121.114.240//2013/04/22/detail_analyse_about_ftp.html</link>
      <pubDate>2010-02-24 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;FTP协议完全详解&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;http://blog.csdn.net/yxyhack/archive/2007/10/15/1826256.aspx
FTP协议完全详解 
1. 介绍
FTP的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。虽然我们也可以手工使用它，但是它的主要作用是供程序使用的。在阅读本文之前最好能够阅读TCP协议标准规范和Telnet协议标准规范。
2. 概览
在本节中我们将讨论一些表面上的问题，有些名词的定义请参阅TCP和Telnet参考文献。我们先介绍一下（1）字节大小，在FTP中字节大小有两个：逻辑字节大小和用于传输的字节大小。后者通常是8位，而前者可不一定是多少了。传输字节不必等于逻辑字节大小，也不必对数据结构进行解释。（2）控制连接是建立在USER-PIT和SERVER-PI之间用于交换命令与应答的通信链路。（3）数据连接是传输数据的全双工连接。传输数据可以发生在服务器DTP和用户DTP之间也可以发生在两个服务器DTP之间。（4）DTP：数据传输过程（DTP）建立和管理数据连接，DTP可以是主动的也可以是被动的。（5）EOR代表记录尾。（6）NTV代表网络虚拟终端，它的定义与在Telnet协议中的定义一致。（7）NVFS代表网络虚拟文件系统。（8）FTP可以传输非连续的文件，这些文件的一部分称为页。（9）PI代表协议解释器。（10）服务器DTP代表一种传输过程，它通常处于“主动”状态，它和侦听端口建立数据连接，它还可以为传输和存储设置参数，并根据PI的指令传输数据。当然，DTP也可以转入“被动”状态。（11）服务器FTP进程，它是和用户FTP进程一起工作的，它由PI和DTP组成。至于用户FTP进程则是由PI，DTP和用户接口组成的。下图是FTP服务示意图：
注意：数据连接是双向的，它不用整个时间都存在。上图中用户PI开始控制连接，控制连接与Telnet协议很象。在开始阶段，标准FTP命令由用户PI产生并通过控制连接传送到服务器进程。服务器PI向用户PI返回标准应答。FTP命令指定数据连接参数和文件系统操作。用户DTP在特定数据端口侦听，服务器开始数据连接并以指定的参数开始数据传输。数据端口不必在开始FTP命令的机器上，但用户或用户FTP进程必须确定它在指定的数据端口上侦听。这个数据连接是全双工的。
在另外一种情况下，用户或许希望在两个主机间传送文件，不是两个本地主机。用户在两台主机间建立控制连接，然后规划数据连接。用这种方式，控制信息由用户PI获得，但是数据在服务器DTP之间传送。下面就是一个例子：

协议要求数据传输在处理时打开控制连接。在完成FTP服务后由用户中止控制连接，而服务器具体操作。如果在未接收命令时关闭了控制连接，服务器也会关闭数据传输。FTP和Telnet很有联系，FTP使用Telnet协议进行控制连接，可有两种方法达到目的：用户PI或服务器PI可以在自己的过程中实现Telnet协议的功能；第二种方法是利用系统中现有的Telnet模块。实现上，FTP对Telnet协议的依赖也不多，即使重新实现，代码量也不大。
3. 数据传输功能
数据连接只传输数据，控制连接传送命令和响应。几个命令是关于在主机间传输数据的，数据传输基本上独立于物理结构的，但是如果在压缩传输模式下流式传输与文件结构有关，文件的属性与表示类型有关。
3.1. 数据表示与保存
数据是在主机间的存储设置间传送的。因为两个系统的数据存储方式不同，因此需要对它进行转换，在传送文本时会有对ASCII表示的问题，在进行二进制传送的时候，会有不同系统对字节长度规定不同的问题，有的系统是7位，有的系统可能是32位，这也需要进行转换。需要提供数据表示与传输模型函数，但是FTP提供这方面的功能不多，超过FTP提供功能的那一部分要用户自己实现。
3.1.1. 数据类型
数据表示是由用户指定的表示类型，它可以是隐含的，也可以是用户指定的。请一定注意：逻辑字节长度与物理字节长度是不同的。
3.1.1.1. ASCII类型
这是所有FTP必须实现的默认类型，用于传送文本文件，当在主机间使用EBCDIC传送时更方便，则不使用ASCII类型。发送方将内部表示转换为NVT-ASCII格式，接收方则进行相反的过程接收数据。根据NVT标准，要在行结束处使用&amp;lt;CRLF&amp;gt;序列。NVT-ASCII是8位的。ASCII和EBCDIC的格式参数在下面讨论。
3.1.1.2. EBCDIC类型
它是作为ASCII的另一种方法在主机间传送数据的数据类型。EBCDIC和ASCII很象，仅在类型的功能描述上有一些差别。行结束符使用很少。
3.1.1.3. 图象类型
在此类型下传送的数据被看作连续的位，发送方将数据打包到8位传输字节中传送。因为结构的需要要对传送数据进行填充，填充字节全部为0，填充必须在文件结构时使用，而且要标记出以便接收方过滤掉。它用于传送二进制数据和有效地传送和存储文件，因此所有FTP也必须实现。
3.1.1.4. 本地类型
也可以以十进制指定逻辑字节大小。如果物理字节大小和逻辑字节大小不同，直接将物理数据打包为逻辑字节，不用什么填充。接收方根据逻辑字节大小进行和本机的存储特点进行转换。传输必须是可重复的，也就是说，相同的文件相同的参数，那内容必须是一样的。
3.1.1.5. 格式控制
ASCII和EBCDIC有一个可选参数，它说明文件垂直格式控制，下面的数据表示类型在FTP中有定义。字符文件可能有三种用途，打印，存储或留待以后处理。如果是用于打印，那主机必须知道垂直格式控制的表示，如果存储或等以后处理，也需要保留文件格式。如果在远程主机上处理完后传输回本地主机，要保证远程主机处理时没有麻烦。这都需要在ASCII和EBCDIC格式上加入新的参数。
3.1.1.5.1. NON PRINT
未指定第二个参数是它是默认值。它必须为所有FTP接受。如果传输的文件是用于打印的，则使用边界和间隔的默认值。通常它不用于打印目的，而用于保存文件或执行文件。
3.1.1.5.2. TELNET格式控制
文件包括ASCII/EBCDIC垂直格式控制，这些控制字符可以使打印正常进行。
3.1.1.5.3. CARRIAGE CONTROL (ASA)
文件包含ASA (FORTRAN)垂直格式控制字符。在以ASA标准形成的行中，第一个字符不打印，它用于决定打印前的走纸量。下面是定义了的ASA字符：
blank： 向下移动1行；0：向下移动2行；1：移动至下一页；+：不移动
打印机必须能够决定结构体的结束。如果文件本身有记录结构就没有问题，如果没有，&amp;lt;CRLF&amp;gt;用于区别打印行，但这些格式标记已经由ASA控制字符使用了。
3.1.2. 数据结构
除了有不同的数据类型外，FTP还允许有不同的文件结构，下面是三种文件结构：文件式结构：文件中没有内部结构，文件被看作是二进制流；记录结构：文件是由一系列记录组成的；页结构：文件是由不同的索引页组成的。
如果未使用STRU命令，文件结构是默认值。文件的结构会影响传输模型，存储和数据表示。文件本来的属性和保存它的主机有关，不同的机器会以自己的方式保存文件。在不同主机间传送文件时必须使主机能够识别相互的表示。有些主机上的文件是面向字节的，有些是面向记录的，在传送时就会出现问题。那就要在接收方进行内部转换。在进行转换的时候，需要区别记录的边界，在ASCII中使用&amp;lt;CRLF&amp;gt;，在EBCDIC中使用&amp;lt;NL&amp;gt;作为分隔符。采用这种实现方法的必须保证转换是可逆的。
3.1.2.1. 文件结构
如果未使用STRU命令，文件结构是默认值。文件结构中没有默认值，文件被看作是连续的字节串。
3.1.2.2. 记录结构
对于文本文件，记录结构必须是所有FTP实现必须有的。记录结构文件是由连续的记录构成的。
3.1.2.3. 页结构
文件是非连续时使用页结构。这种文件称为随机访问文件。这些文件中有时会的和文件整体或部分相关的信息出现。在FTP中，文件的一个部分称为页。为了提供不同的页大小和相关信息，每页都带页头发送。页头中有如下域：
头长度
包括此字节的页头长度，单位为字节，最小长度为4

页索引
指出此部分在原文件中的位置，它和传输编号不是一回事

数据长度
页数据中的逻辑字节数，最小值为0

页类型
页的类型有以下几种：0=未页，指示传输结构，包头必须为4，数据长度必须为0；1=通常页，没有控制信息的通常页文件的普通类型；2=描述子页，用于传送整体文件的描述信息；3=访问控制页，包括页级访问控制信息的页文件头域，包头长度必须为5

可选域
提供每页的控制信息

描述子 8位
字节计数 16位
描述子代码由在描述子字节中的位标记说明，下面是已经指定的四种代码及其意义：
代码
意义

128
数据块结束是EOR

64
数据块结束是EOF

32
数据块内有怀疑错误

16
数据块是重新开始标记
　　
　
以这种编码，对于特定块可能存在多个描述子编码条件，所需要的位必须全部设置。重新开始标记包括在数据流中，它作为8位整数代表在控制连接上使用语言的可打印字节，但&amp;lt;SP&amp;gt;不得出现在其中。例如要传送6字节标记，下面就是例子：
Descrptr code = 16
Byte count = 6

　
Marker 8位
Marker 8位
Marker 8位

　
Marker 8位
Marker 8位
Marker 8位
3.4.3. 压缩模式
有三种信息需要传送：常规数据以字节串传送；压缩数据，包括复本和过滤器；控制信息，以两个转义字符传送。如果有N（&amp;gt;0但小于127）个常规数据传送，在数据前一位加上一个字节，这个字节最高位为0，其它位表示的数值等于N。如下图：

若要压缩一个数据位D的N复本字符串，用两个字节传送，如下图，它表示的是压缩的字节：

一串N过虑器字节可以压缩为一个字节，而过滤器字节根据表示法不同而不同。如果类型是ASCII或EBCDIC，过滤器字节是&amp;lt;SP&amp;gt;，如果是图象或本地类型，则是0。下面就是过滤器字节：

转义序列是双字节，头一个全0，后一个内是定义于块模式下的描述子代码。描述子代码与块模式中的意义相同，它作用于其后串中的字节。而压缩模式对于增加带宽有好处（因为数据是压缩过的）。
3.5. 差错恢复和重新开始
位丢失和数据错误是这一层的差错控制由TCP负责。而重新开始则是给用户一个处理系统（包括操作系统，网络等）失败的方法。重新开始过程仅适用于块和压缩模式，它要求发送者在数据流中加入特定标记，标记仅对传送者有意义，但其中的内容是控制连接使用的语言。标记可以代表一个位记数，记录记数或可以标记数据数目的任何点。如果接收方也支持重新开始，将会在接收系统中保存这一标记。在系统失败重新启动后，用户可以根据原来的标记重新开始数据传送，也就是我们通常熟悉的断点续传过程。接收方接收到一段数据，然后记下一点，如果发送方失败了，就从这一点以后再传送相应的数据。具体的这里不多说了。
4. 文件传输功能
从用户PI到服务器的信道是建立在用户到标记服务器端口间的。用户协议解释器负责发送命令和解释接收的应答；服务器PI解释命令，发送应答，指导DTP建立数据连接并传送数据。如果数据传输的第二方是用户DTP，通过用户FTP主机的内部协议对它进行控制；如果第二方是服务器DTP，它由用户PI发来的命令经过自己的PI控制。
4.1. FTP命令
4.1.1. 访问控制命令
下列命令指定访问控制标记（命令码在括号内）：
用户名(USER)
参数是标记用户的Telnet串。用户标记是访问服务器必须的，此命令通常是控制连接后第一个发出的命令，有些主机还会要求口令和帐户。服务器可以在任何时间接收新的USER命令以改变访问控制和（或）帐户信息。这可以重新开始登录过程，所以传输参数不变，在进行中的文件传输在过去的访问控制参数下完成。
口令(PASS)
参数是标记用户口令的Telnet串。此命令紧跟USER命令，在某些站点它是完成访问控制不可缺少的一步。因此口令是个重要的东西，因此不能显示出来，服务器方没有办法隐藏口令，所以这一任务得由用户FTP进程完成。
ACCOUNT (ACCT)
　
参数是标记用户帐户的Telnet串。此命令不需要与USER相关，一些站点可能需要帐户用于登录，另一些可以限制帐户的权限，在后一种情况下，此命令可在任何时候发送。应答的不同可以区别不同的情况：当登录需要帐户信息时，对PASS命令的响应是332。另外，如果不需要帐户信息，对PASS的响应是230，如果需要帐户信息在以后需要，服务器会返回332或532，这要看它是保存此命令还是拒绝此命令了。
改变工作目录(CWD)
此命令使用户可以在不同的目录或数据集下工作而不用改变它的登录或帐户信息。传输参数也不变。参数一般是目录名或与系统相关的文件集合。
回到上一层目录(CDUP)
此命令要求系统实现目录树结构，它的响应和CWD的相同。
结构加载(SMNT)
此命令使用户在不改变登录或帐户信息的情况下加载另一个文件系统数据结构。传输参数也不变。参数是文件目录或与系统相关的文件集合。
重新初始化(REIN)
此命令终止USER，将所有I/O和帐户信息写入，但不许进行中的数据传输完成。重置所有参数，控制连接打开，可以再次开始USER命令。
退出登录(QUIT)
此命令终止USER，如果没有数据传输，服务器关闭控制连接；如果有数据传输，在得到传输响应后服务器关闭控制连接。如果用户进程正在向不同的USER传输数据，不希望对每个USER关闭然后再打开，可以使用REIN。对控制连接的意外关闭，可以导致服务器运行中止(ABOR)和退出登录(QUIT)。
4.1.2. 传输参数命令
所有数据传输参数有默认值。服务器必须记录下默认值，在FTP服务请求后，可以以任何顺序发送。下面命令传送参数：
数据端口(PORT)
　
参数是要使用的数据连接端口，通常情况下对此不需要命令响应。如果使用此命令时，要发送32位的IP地址和16位的TCP端口号。上面的信息以8位为一组，逗号间隔十进制传输，如下例：
PORT h1,h2,h3,h4,p1,p2
其中h1是IP地址的最高8位。
被动(PASV)
此命令要求服务器DTP在指定的数据端口侦听，进入被动接收请求的状态，参数是主机和端口地址。
表示类型(TYPE)
参数指定表示类型。有些类型需要第二个参数，第一个参数由单个Telnet字符定义，第二个参数是十进制整数指定字节大小，参数间以&amp;lt;SP&amp;gt;分隔。下面是格式：
默认表示类型是ASCII非打印字符，如果参数未改变，以后只改变了第一个参数，则使用默认值。
文件结构(STRU)
参数是一个Telnet字符代码指定文件结构。下面是代码及其意义：
F - 文件（非记录结构），它是默认值
R - 记录结构
P - 页结构
传输模式(MODE)
参数是一个Telnet字符代码指定传输模式。下面是代码及其意义：
S - 流（默认值）
B - 块
C - 压缩
4.1.3. FTP服务命令
FTP服务命令定义用户请求的文件传输或文件系统功能。此命令的参数通常是路径名，其语法要和服务器的规范一致。推荐的默认值是最近指定的设备目录或目录。命令顺序通常没有限制，只有&amp;quot;rename from&amp;quot;命令后面必须是&amp;quot;rename to&amp;quot;，重新启动命令后面必须是中断服务命令。服务命令的响应通常在数据连接上传输。下面是具体的命令：
获得文件(RETR)
此命令使服务器DTP传送指定路径内的文件复本到服务器或用户DTP。这边服务器上文件的状态和内容不受影响。
保存(STOR)
此命令使服务器DTP接收数据连接上传送过来的数据，并将数据保存在服务器的文件中。如果文件已存在，原文件将被覆盖。如果文件不存在，则新建文件。
唯一保存(STOU)
此命令和STOR差不多，此命令要求在此目录下的文件名是唯一的，对此命令的响应必须包括产生的用户名。
附加(APPE)
它和STOR的功能差不多，但是如果文件在指定路径内已存在，则把数据附加到原文件尾部，如果不存在则新建文件。
分配(ALLO)
此命令用于在一些主机上为新传送的文件分配足够的存储空间。参数是十进制的逻辑字节数。如果是记录或页结构，页或记录的最大大小也需要，这在第二个参数内以十进制指定。第二个参数是可选的，如果有它，它和第一个参数以Telnet字符&amp;lt;SP&amp;gt; R &amp;lt;SP&amp;gt;分隔。此命令在STOR或APPE命令后，对于不需要分配存储空间的机器，它的作用等于NOOP。
重新开始(REST)
参数域代表服务器要重新开始的那一点，此命令并不传送文件，而是略过指定点后的数据，此命令后应该跟其它要求文件传输的FTP命令。
重命名(RNFR)
这个命令和我们在其它操作系统中使用的一样，只不过后面要跟&amp;quot;rename to&amp;quot;指定新的文件名。
重命名为(RNTO)
此命令和上面的命令共同完成对文件的重命名。
放弃(ABOR)
此命令通知服务中止以前的FTP命令和与之相关的数据传送。如果先前的操作已经完成，则没有动作，返回226。如果没有完成，返回426，然后再返回226。关闭控制连接，数据连接不关闭。
删除(DELE)
此命令删除指定路径下的文件。用户进程负责对删除的提示。
删除目录(RMD)
此命令删除目录。
创建目录(MKD)
此命令在指定路径下创建新目录。
打印工作目录(PWD)
在响应是返回当前工作目录。
列表(LIST)
服务器传送列表到被动DTP，如果路径指定一个目录或许多文件，返回指定路径下的文件列表。如果路径名指定一个文件，服务器返回文件的当前信息，参数为空表示用户当前的工作目录或默认目录。数据传输在ASCII或EBCDIC下进行，用户必须确认这一点。因为文件信息因系统不同而不同，所以不可能被程序自动利用，但是人类用户却很需要。
名字列表(NLST)
服务器传送目录表名到用户，路径名应指定目录或其它系统指定的文件群描述子；空参数指当前目录。服务器返回文件名数据流，以ASCII或EBCDIC形式传送，并以&amp;lt;CRLF&amp;gt;或&amp;lt;NL&amp;gt;分隔。这里返回的信息有时可以供程序进行进一步处理。
站点参数(SITE)
服务器用来提供服务器系统信息，信息因系统不同而不同，格式在HELP SITE命令应答中给出。
系统(SYST)
用于确定服务器上运行的操作系统。
状态(STAT)
此命令返回控制连接状态，它可以在文件传送过程中发送，服务器返回操作进行的状态。也可以在文件传送之间发送，这时命令有参数，参数是路径名，此命令的功能除了数据在控制连接上传送以外和列表命令相似。如果指定部分路径，服务器以文件名或与说明相关的属性返回；如没有参数，服务器返回服务器FTP进程的状态信息，包括传输参数的当前值和连接状态。
帮助(HELP)
这条命令我们在平常系统中得到的帮助没有什么区别，响应类型是211或214。建议在使用USER命令前使用此命令。
等待(NOOP)
此命令不产生什么实际动作，它仅使服务器返回OK。
FTP在控制连接上使用Telnet通信，因此有机会大家可以看看相关的协议说明。对下文的理解会很有好处。下面内容将对命令的应答和关于命令的详细信息作以说明。FTP命令可分为访问控制标记，数据传输参数或FTP服务请求，特定的命令（如ABOR，STAT）可以在数据传输过程中在控制连接上传输。有些服务器不能同时监视数据和控制链路，那就要另外采取措施了。请注意下面的几点建议：
1. 用户系统将Telnet的&amp;quot;Interrupt Process&amp;quot;（IP）信息插入Telnet流；
2. 用户系统发送Telnet的&amp;quot;Synch&amp;quot;信号；
3. 用户系统将命令（如ABOR）插入Telnet流；
4. 服务器PI在接收到IP后，在Telnet流中寻找仅有一个的FTP命令。
4.2. FTP应答
FTP命令的响应是为了对数据传输请求和过程进行同步，也是为了让用户了解服务器的状态。每个命令必须有最少一个响应，如果是多个，它们要易于区别。有些命令是有顺序性的，因此其中任何一个命令的失败会导致从头开始。FTP响应由三个数字构成，后面是一些文本。数字带有足够的信息命名用户PI不用检查文本就知道发生了什么。文本信息与服务器相关，用户可能得到不同的文本信息。文本和数字以&amp;lt;SP&amp;gt;间隔，文本后以Telnet行结束符结束。文本可能多于一行，这时文本必须在括号内，第一行内要有信息表示文本多于一行，最后一行也要有所标记。如果是多行，可以在数字代码后加上&amp;quot;-&amp;quot;，最后一行以数字开始，后面是&amp;lt;SP&amp;gt;，再加上Telnet的行结束符就可以了。下面是一个例子：
123-第一行
第二行
     234 以数字开始的一行
123 最后一行
三位数字每位都有一定的意义，第一位确定响应是好的，坏的还是不完全的，通过检查第一位，用户进程通常就能够知道大致要采取什么行动了。如果用户程序希望了解出了什么问题，可以检查第二位，第三位留表示其它信息。第一位有五个值：
1yz 确定预备应答
请求的操作正在被初始化；在进入下一个命令前等待另外的应答。这类响应用于说明命令被接受，在实现中如何同步监视有困难，用户进程现在可以关注数据连接了。服务器FTP进程对第个命令几乎都返回1yz响应。
2yz 确定完成应答
要求的操作已经完成，可以执行新命令。
3yz 确定中间应答
命令已接受，但要求的操作被停止，停止接收更新的信息。
4yz 暂时拒绝完成应答
未接受命令，要求的操作未执行，但错误是临时的，过一会儿可以再次发送消息。用户应该返回命令序列的开始。这个暂时可是不好确定，此命令的意思就是让用户进程再次尝试使用此命令。
5yz 永远拒绝完成应答
它与暂时拒绝完成应答的区别就在于错误条件是一时半会不会消失。
下面我们来看看第二位所代表的意义：
x0z 格式错误；
x1z 此类应答是为了请求信息的；
x2z 此类应答是关于控制和数据连接的；
x3z 关于认证和帐户登录过程；
x4z 未使用；
x5z 此类应答是关于文件系统的；
第三个数字是在第二个数字的基础上对应答内容的进一步细化。一般来说，数字代码后要有文本信息。实现时应该尽量使用现有的代码，而不要随便添加新的意义不大的代码。
有些命令如TYPE或ALLO，它们的成功不为用户进程提供任务新信息，所以不会有200应答返回。如果有些命令对于服务器来说不支持，也要返回确定完成应答，这样用户进程才有可能进行下面的命令。如果要求的不是可选实现的命令，而这个命令确实没有实现，那就要返回代码502。下面我们根据数字顺序列出各个应答码及其意义：
110
重新启动标记应答。在这种情况下文本是确定的，它必须是：MARK yyyy=mmmm，其中yyyy是用户进程数据流标记，mmmm是服务器标记。

120
服务在nnn分钟内准备好

125
数据连接已打开，准备传送

150
文件状态良好，打开数据连接

200
命令成功

202
命令未实现

211
系统状态或系统帮助响应

212
目录状态

213
文件状态

214
帮助信息，信息仅对人类用户有用

215
名字系统类型

220
对新用户服务准备好

221
服务关闭控制连接，可以退出登录

225
数据连接打开，无传输正在进行

226
关闭数据连接，请求的文件操作成功

227
进入被动模式

230
用户登录

250
请求的文件操作完成

257
创建&amp;quot;PATHNAME&amp;quot;

331
用户名正确，需要口令

332
登录时需要帐户信息

350
请求的文件操作需要进一步命令

421
不能提供服务，关闭控制连接

425
不能打开数据连接

426
关闭连接，中止传输

450
请求的文件操作未执行

451
中止请求的操作：有本地错误

452
未执行请求的操作：系统存储空间不足

500
格式错误，命令不可识别

501
参数语法错误

502
命令未实现

503
命令顺序错误

504
此参数下的命令功能未实现

530
未登录

532
存储文件需要帐户信息

550
未执行请求的操作

551
请求操作中止：页类型未知

552
请求的文件操作中止，存储分配溢出

553
未执行请求的操作：文件名不合法

5. 说明
5.1. 最小实现
下面是FTP服务器的最小实现：
类型 - ASCII Non-print
模式 - Stream
结构 - File, Record
命令 - USER, QUIT, PORT,TYPE, MODE, STRU,RETR, STOR,NOOP.
传输的默认参数为：
类型 - ASCII Non-print
模式 - Stream
结构 - File
所有主机都将上面的值作为默认值。
5.2. 连接
服务器协议解释器会在端口L侦听，用户或用户协议解释器初始化全双工控制连接，服务器和用户进程应该遵守Telnet协议的说明进行。服务器不提供对命令行的编辑功能，应该由用户负责这一切。在全部传送和应答结束后，在用户的请求下服务器关闭控制连接。用户DTP必须在指定的数据端口上侦听，它可以是默认端口U或由PORT命令指定的端口。服务器的默认数据端口为L-1。传输方向和端口均可由FTP命令决定。只有用户PI可以改变默认端口。当数据在服务器A和B之间传送时，用户PI，C，在两个服务器PI之间建立控制连接。其中一个服务器A，在接收到传输服务命令时接收PASV命令初始化连接，用户PI接收到PASV命令的确认时（确认内包括主机标识和端口），将端口以PORT命令发送到B。在接收到确认后，用户PI可以发送相应的命令给A和B了，B初始连接和传输进程，命令应答序列如下面所示，请根据位置注意时差：
在任何时间，服务器和用户只要有一方关闭连接，另一方就要赶快读取缓冲中的数据，然后也关闭本方的连接。
5.3. 命令
本节主要讨论命令格式。命令对大小写不敏感。命令通常由命令码和相应的参数组成。中间由一个或几个空格分开。参数域由&amp;lt;CRLF&amp;gt;结束，服务器在未接收到行结束符时不会采取任何动作。下面描述的格式是以NVT-ASCII以准的，方括号代表可选的参数域，如果未选择可选的参数域则采用默认值。
5.3.1. FTP命令
下面是FTP命令，其中username代表用户名，password代表口令，pathname代表路径名，host-port代表主机端口，account-information代表帐户信息，typecode代表类型代码，decimal-integer代表十进制整数，marker代表标记，string代表字符串：
USER &amp;lt;SP&amp;gt; &amp;lt;username&amp;gt; &amp;lt;CRLF&amp;gt;
PASS &amp;lt;SP&amp;gt; &amp;lt;password&amp;gt; &amp;lt;CRLF&amp;gt;
ACCT &amp;lt;SP&amp;gt; &amp;lt;account-information&amp;gt; &amp;lt;CRLF&amp;gt;
CWD &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
CDUP &amp;lt;CRLF&amp;gt;
SMNT &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
QUIT &amp;lt;CRLF&amp;gt;
REIN &amp;lt;CRLF&amp;gt;
PORT &amp;lt;SP&amp;gt; &amp;lt;host-port&amp;gt; &amp;lt;CRLF&amp;gt;
PASV &amp;lt;CRLF&amp;gt;
TYPE &amp;lt;SP&amp;gt; &amp;lt;type-code&amp;gt; &amp;lt;CRLF&amp;gt;
STRU &amp;lt;SP&amp;gt; &amp;lt;structure-code&amp;gt; &amp;lt;CRLF&amp;gt;
MODE &amp;lt;SP&amp;gt; &amp;lt;mode-code&amp;gt; &amp;lt;CRLF&amp;gt;
RETR &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
STOR &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
STOU &amp;lt;CRLF&amp;gt;
APPE &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
ALLO &amp;lt;SP&amp;gt; &amp;lt;decimal-integer&amp;gt;
[&amp;lt;SP&amp;gt; R &amp;lt;SP&amp;gt; &amp;lt;decimal-integer&amp;gt;] &amp;lt;CRLF&amp;gt;
REST &amp;lt;SP&amp;gt; &amp;lt;marker&amp;gt; &amp;lt;CRLF&amp;gt;
RNFR &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
RNTO &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
ABOR &amp;lt;CRLF&amp;gt;
DELE &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
RMD &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
MKD &amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt; &amp;lt;CRLF&amp;gt;
PWD &amp;lt;CRLF&amp;gt;
LIST [&amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt;] &amp;lt;CRLF&amp;gt;
NLST [&amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt;] &amp;lt;CRLF&amp;gt;
SITE &amp;lt;SP&amp;gt; &amp;lt;string&amp;gt; &amp;lt;CRLF&amp;gt;
SYST &amp;lt;CRLF&amp;gt;
STAT [&amp;lt;SP&amp;gt; &amp;lt;pathname&amp;gt;] &amp;lt;CRLF&amp;gt;
HELP [&amp;lt;SP&amp;gt; &amp;lt;string&amp;gt;] &amp;lt;CRLF&amp;gt;
NOOP &amp;lt;CRLF&amp;gt;
5.3.2. FTP命令参数
下面是用BNF范式表示的参数格式：
&amp;lt;username&amp;gt; ::= &amp;lt;string&amp;gt;
&amp;lt;password&amp;gt; ::= &amp;lt;string&amp;gt;
&amp;lt;account-information&amp;gt; ::= &amp;lt;string&amp;gt;
&amp;lt;string&amp;gt; ::= &amp;lt;char&amp;gt; | &amp;lt;char&amp;gt;&amp;lt;string&amp;gt;
&amp;lt;char&amp;gt; ::= 除&amp;lt;CR&amp;gt;和&amp;lt;LF&amp;gt;外的所有ASCII字符
&amp;lt;marker&amp;gt; ::= &amp;lt;pr-string&amp;gt;
&amp;lt;pr-string&amp;gt; ::= &amp;lt;pr-char&amp;gt; | &amp;lt;pr-char&amp;gt;&amp;lt;pr-string&amp;gt;
&amp;lt;pr-char&amp;gt; ::= 可打印ASCII字符，从33到126
&amp;lt;byte-size&amp;gt; ::= &amp;lt;number&amp;gt;
&amp;lt;host-port&amp;gt; ::= &amp;lt;host-number&amp;gt;,&amp;lt;port-number&amp;gt;
&amp;lt;host-number&amp;gt; ::= &amp;lt;number&amp;gt;,&amp;lt;number&amp;gt;,&amp;lt;number&amp;gt;,&amp;lt;number&amp;gt;
&amp;lt;port-number&amp;gt; ::= &amp;lt;number&amp;gt;,&amp;lt;number&amp;gt;
&amp;lt;number&amp;gt; ::= 从1到255的十进制整数
&amp;lt;form-code&amp;gt; ::= N | T | C
&amp;lt;type-code&amp;gt; ::= A [&amp;lt;sp&amp;gt; &amp;lt;form-code&amp;gt;]| E [&amp;lt;sp&amp;gt; &amp;lt;form-code&amp;gt;]| I| L &amp;lt;sp&amp;gt; &amp;lt;byte-size&amp;gt;
&amp;lt;structure-code&amp;gt; ::= F | R | P
&amp;lt;mode-code&amp;gt; ::= S | B | C
&amp;lt;pathname&amp;gt; ::= &amp;lt;string&amp;gt;
&amp;lt;decimal-integer&amp;gt; ::= 任何十进制整数
5.4. 命令和响应序列
服务器和用户之间的通信是对话的过程，用户发送FTP命令，然后等待服务器的一个（或多个）响应，根据响应再发送新命令。
连接时的响应带有许多信息，通常情况下，服务器会返回220应答，等待输入，用户在接收到此响应后才发送新命令，如果服务器不能立即接收输入，会在220后面返回120。有些信息如服务器将在15分钟后停止工作是要服务器发向用户的，但是服务器却不能直接发向用户，处理的方法是将消息缓冲，在下一个响应中返回给用户。下面列出命令的应答，第一个是预备应答，第二个是确定完成，第三个是拒绝完成，最后是中间应答。这些应答是构成状态图的基础，状态图会在下节中给出：
建立连接 120 
220
220
421
登录
USER
230
530
500, 501, 421
331, 332
PASS
230
202
530
500, 501, 503, 421
332
ACCT
230
202
530
500, 501, 503, 421
CWD
250
500, 501, 502, 421, 530, 550
CDUP
200
500, 501, 502, 421, 530, 550
SMNT
202, 250
500, 501, 502, 421, 530, 550
退出登录
REIN
120
220
220
421
500, 502
QUIT
221
500
传输参数
PORT
200
500, 501, 421, 530
PASV
227
500, 501, 502, 421, 530
MODE
200
500, 501, 504, 421, 530
TYPE
200
500, 501, 504, 421, 530
STRU
200
500, 501, 504, 421, 530
文件操作命令
ALLO
200
202
500, 501, 504, 421, 530
REST
500, 501, 502, 421, 530
350
STOR
125, 150
(110)
226, 250
425, 426, 451, 551, 552
532, 450, 452, 553
500, 501, 421, 530
STOU
125, 150
(110)
226, 250
425, 426, 451, 551, 552
532, 450, 452, 553
500, 501, 421, 530
RETR
125, 150
(110)
226, 250
425, 426, 451
450, 550
500, 501, 421, 530
LIST
125, 150
226, 250
425, 426, 451
450
500, 501, 502, 421, 530
NLST
125, 150
226, 250
425, 426, 451
450
500, 501, 502, 421, 530
APPE
125, 150
(110)
226, 250
425, 426, 451, 551, 552
532, 450, 550, 452, 553
500, 501, 502, 421, 530
RNFR
450, 550
500, 501, 502, 421, 530
350
RNTO
250
532, 553
500, 501, 502, 503, 421, 530
DELE
250
450, 550
500, 501, 502, 421, 530
RMD
250
500, 501, 502, 421, 530, 550
MKD
257
500, 501, 502, 421, 530, 550
PWD
257
500, 501, 502, 421, 550
ABOR
225, 226
500, 501, 502, 421
获得信息命令
SYST
215
500, 501, 502, 421
STAT
211, 212, 213
450
500, 501, 502, 421, 530
HELP
211, 214
500, 501, 502, 421
其它命令
SITE
200
202
500, 501, 530
NOOP
200
500 421
6. 状态图
下面是一个简单实现的FTP的状态图，只用到响应码的首位。对于所有命令或命令序列有三种可能性：成功（S），失败（F）或错误（E）。在状态图中B代表开始，W代表等待响应。下面我们给出一个总图，总图可以包括的命令有：
ABOR，ALLO，DELE，CWD，CDUP，SMNT，HELP，MODE，NOOP，PASV,QUIT，SITE，PORT，SYST，STAT，RMD，MKD，PWD，STRU和TYPE
而下图可以包括的命令有：APPE，LIST，NLST，REIN，RETR，STOR和STOU。
第一幅图和第二幅图差别不大，第一幅图中如果出现了100系列响应会是错误，而在第二幅图中不会。下面是重命名过程：
下面是重新启动命令，其中cmd代表APPE,STOR或RETR。
下图代表登录过程：
7. 典型FTP过程
假设位于U的用户希望从S上（下）传文件，通常用户需要使用用户FTP进程和服务器通信，下面就是一个例子：
用户发出的本地命令
解释

ftp (host) multics&amp;lt;CR&amp;gt;
连接到S的端口L，建立控制连接
&amp;lt;---- 220 Service ready &amp;lt;CRLF&amp;gt;.

用户名 Doe &amp;lt;CR&amp;gt;
need password&amp;lt;CRLF&amp;gt;.
USER Doe&amp;lt;CRLF&amp;gt;----&amp;gt;
&amp;lt;---- 331 用户名正确

口令 &amp;lt;CR&amp;gt;
PASS 口令&amp;lt;CRLF&amp;gt;----&amp;gt;
&amp;lt;---- 230 User logged in&amp;lt;CRLF&amp;gt;.

retrieve (local type) ASCII&amp;lt;CR&amp;gt;
(local pathname) test 1 &amp;lt;CR&amp;gt;
(for. pathname) test.pl1&amp;lt;CR&amp;gt;
User-FTP opens local file in ASCII.
RETR test.pl1&amp;lt;CRLF&amp;gt; ----&amp;gt;
&amp;lt;---- 150 文件状态正常，将打开数据连接&amp;lt;CRLF&amp;gt;
服务器于端口U建立数据连接

文件传输中

　
&amp;lt;---- 226 关闭数据连接，文件传输正确&amp;lt;CRLF&amp;gt;

type Image&amp;lt;CR&amp;gt;
TYPE I&amp;lt;CRLF&amp;gt; ----&amp;gt;
&amp;lt;---- 200 Command OK&amp;lt;CRLF&amp;gt;

store (local type) image&amp;lt;CR&amp;gt;
(local pathname) file dump&amp;lt;CR&amp;gt;
(for.pathname) &amp;gt;udd&amp;gt;cn&amp;gt;fd&amp;lt;CR&amp;gt;
User-FTP opens local file in Image.
STOR &amp;gt;udd&amp;gt;cn&amp;gt;fd&amp;lt;CRLF&amp;gt; ----&amp;gt;
&amp;lt;---- 550 访问拒绝&amp;lt;CRLF&amp;gt;

中止
QUIT &amp;lt;CRLF&amp;gt; ----&amp;gt;

服务器关闭所有连接

FTP控制连接通过用户进程端口U和服务器端口L建立，这里默认的L=21。

所有域均以1个逻辑字节长度为大小，逻辑字节长度由TYPE命令指定。如果读取版本与和开始版本号一致，文件访问时必须以相同的参数进行。如果参数相同，FTP实现要保证取得的文件内容是相同的。
3.2. 建立数据连接
传送数据机制包括建立连接选择数据参数。用户和服务器DTP有默认数据端口。用户进程默认数据端口和控制连接端口相同。服务器进程默认数据端口和控制连接端口相邻。传输字节大小是8位字节。此字节是实际传输字节，但不代表主机内的数据表示。被动数据传输进程在数据端口接收数据，FTP请求命令决定数据传输的方向。服务器在接收到请求以后，将初始化端口的数据连接。当连接建立后，传输在DTP之间传送，服务器PI对用户PI返回应答。FTP实现运行一个默认数据端口，用户PI才能改变默认端口。
通过PORT命令可能改变端口，用户可能希望数据在第三方主机上进行其它操作，用户PI需要在两个服务器PI上建立连接。一个服务器被告知侦听另一服务器的请求。用户PI通过PORT命令通知另一服务器的数据端口。最后双方发送相应的传送命令。通常，服务器负责支持数据连接，初始化并关闭它，除非用户DTP在传输模式下要求关闭连接。服务器在下面情况下关闭数据连接：
1. 服务器结束发送数据，通过EOF要求中止传送；
2. 用户发送ABORT命令；
3. 用户改变端口；
4. 控制连接关闭；
5. 发生不可恢复错误。
3.3. 数据连接管理
默认数据连接端口：所有FTP必须支持默认数据连接，只有用户PI能够初始化非默认端口的使用。
确定非默认数据端口：用户PI可以使用PORT命令指定非默认端口，它要求服务器方以PASV确定非默认数据端口。连接是由双方地址确定的，因此改变一方地址就改变了连接。
数据连接的重用：在使用流式数据传输模型时，文件结束通过关闭连接指示。如果要传送多个文件时就会出麻烦，解决的方法有两个，一个是确定非默认端口，另一个是使用另一种传输模式。就传输模式而言，流传输模式是不安全的，因此无法确定连接是暂时还是永久关闭。其它传输模式不通过关闭连接表示文件结构，它们可以通过FTP命令决定传送结构。因此使用这些传输模式可以在保持连接的情况下传送多个文件。
3.4. 传输模式
有三种传输模式：一种将数据格式化并考虑重新开始过程；一种压缩数据；一种是不经过处理（少量处理）传送。所有数据传输必须以一个EOF结束，它可以显式给出，也可以通过关闭连接隐式给出。对于记录文件，所有EOR是显式的，包括最后一个记录。对于以页结构传送的文件，使用“最后一页”表示结束。从这里开始，下文中我们提到的字节指的是“传输字节”。
为了进行标准化传送，传送主机必须把行结束或记录结束的内部表示转化为传输模式和文件结构指定的形式传送，接收方则进行相反的工作。IBM大型机的记录计数域可能不能为其它主机识别，所以记录结束标记在流模式下以双字节控制码传送，在块或压缩模式下以标记位传送。而ASCII或EBCDIC的行结束则则&amp;lt;CRLF&amp;gt;或&amp;lt;NL&amp;gt;指示。这样的转换需要时间，所以相同的系统在传送文本文件时采用二进制或流表示比较合适。下面是FTP定义的传输模式：
3.4.1. 流模式
数据以字节流的形式传送。使用的表示类型没有限制，允许记录结构。在记录结构文件EOR和EOF表示为双字节控制码。第一字节全为0，后一字节为转义字符。当第二位值为1时表示EOR，为2时表示EOF，如果要同时表示EOR和EOF，值为3。全1字节作为数据发送时必须使用双字节传送，其中数据保存在第二个字节内。如果是文件结构，通过发送方关闭连接表示EOF，接收到的所有数据就是文件内容。
3.4.2. 块模式
文件以块形式传送，块带有自己的头部分。头字节包括计数域和描述子代码。计数域说明了数据块的字节数，描述子代码定义了以下内容：EOF，EOR重新开始标记或怀疑错误数据。怀疑错误数据不是为了进行差错控制，它是为了站点间交换特定数据，传送时不管本地错误（如硬盘错误）而只管传送，但是传送时可要指出，这个数据可能有错。在此模式下可以使用记录结构，也可以使用相应的数据表示。头字节的结构如下图所示：
本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/yxyhack/archive/2007/10/15/1826256.aspx
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
  </channel>
</rss>