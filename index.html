<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Start Point</title>
  
    <meta name="author" content="taoxiaoseng">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="42.121.114.240/assets/twitter/stylesheets/bootstrap.min.css" type="text/css" rel="stylesheet" media="all">
<link href="42.121.114.240/assets/twitter/stylesheets/style.css" type="text/css" rel="stylesheet" media="all">
<link href="42.121.114.240/assets/twitter/widgets/google_prettify/stylesheets/twitter-bootstrap.css" type="text/css" rel="stylesheet" media="all">
 
    
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/" style="padding-left:46px;">淘小僧</a>
          <ul class="nav">
            
              


  <li><a href="/archive">Archive</a></li>


            
              


  <li><a href="/tags">Tags</a></li>


            
              


  <li><a href="/categories">Categories</a></li>


            
              


  <li><a href="/pages">Pages</a></li>


            
              


  <li><a href="/about">About Me</a></li>


            
          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>Start Point </h1>
</div>

<div class="row">
  <div class="span12">
    
It's copy of my steps.
<h3>最近更新</h3>


<div class="post">
  <!--<h4 class="title"><a href="/2013/10/04/manytips.html">many tips</a> <span class="date">2013-10-04</span></h3>-->
  <h4 class="title"><a href="/2013/10/04/manytips.html">many tips</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;many tips</p>
  <!--<h1>Tips</h1>

<ol>
<li>问：[centos]Can&rsquo;t ssh to server with root account because of gitosis?
答：Just remove /root/.ssh/authorized_keys</li>
</ol>
-->

  <!--<div class="more">
    <a href="/2013/10/04/manytips.html" class="btn">read more..</a>
  </div>-->
</div>

<div class="post">
  <!--<h4 class="title"><a href="/2013/10/01/coretext.html">Core Text</a> <span class="date">2013-10-01</span></h3>-->
  <h4 class="title"><a href="/2013/10/01/coretext.html">Core Text</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;core text</p>
  <!--<p>#Core Text</p>

<ol>
<li>Here you need to create a path which bounds the area where you will be drawing text. Core Text on the Mac supports different shapes like rectangles and circles, but for the moment iOS supports only rectangular shape for drawing with Core Text. In this simple example, you’ll use the entire view bounds as the rectangle where you will be drawing by creating a CGPath reference from self.bounds.</li>
</ol>
-->

  <!--<div class="more">
    <a href="/2013/10/01/coretext.html" class="btn">read more..</a>
  </div>-->
</div>

<div class="post">
  <!--<h4 class="title"><a href="/2013/09/21/iosDevTip.html">IOS开发</a> <span class="date">2013-09-21</span></h3>-->
  <h4 class="title"><a href="/2013/09/21/iosDevTip.html">IOS开发</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;core text</p>
  <!--<p>app打开默认是混合音模式
开始录音的时候如果选择的模式是playandrecord，则也能支持播放。</p>

<p>ios7系统里跑ios6兼容模式，删除按钮的位置有变化</p>
-->

  <!--<div class="more">
    <a href="/2013/09/21/iosDevTip.html" class="btn">read more..</a>
  </div>-->
</div>

<div class="post">
  <!--<h4 class="title"><a href="/2013/08/12/tips_when_install_node_modules.html">tips_when_install_node_modules</a> <span class="date">2013-08-12</span></h3>-->
  <h4 class="title"><a href="/2013/08/12/tips_when_install_node_modules.html">tips_when_install_node_modules</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;安装node工程代码及安装node_modules的注意</p>
  <!--<h1>安装自己的node代码及安装node_modules的注意</h1>

<ol>
<li><p>package.json里的版本号似乎需要1.0.1这种类似的格式</p></li>

<li><p>将你的代码打包后，你需要在其他未安装的服务器上运行时，则你可能需要临时安装你的node相关的node_module，此时你可以不要将你原来的代码里的nodemoudle带过来，而是通过npm install安装node module模块，当然最好是要求你的node module里的模块的版本和你开发测试的版本一致。否则你可能会出现异常的情况。所以注意修改设置你的package.json里的相关依赖模块的版本号</p></li>

<li></li>
</ol>
-->

  <!--<div class="more">
    <a href="/2013/08/12/tips_when_install_node_modules.html" class="btn">read more..</a>
  </div>-->
</div>

<div class="post">
  <!--<h4 class="title"><a href="/2013/08/12/how_to_use_async_in_nodejs.html">Nodejs中的async的使用</a> <span class="date">2013-08-12</span></h3>-->
  <h4 class="title"><a href="/2013/08/12/how_to_use_async_in_nodejs.html">Nodejs中的async的使用</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;关于async中auto方法的简要说明</p>
  <!--<h1>Nodejs中的async的使用</h1>

<p>Nodejs中最最感觉不舒服的是因为全异步引起的代码层级变的更大而导致阅读更加麻烦。
所以解决因为nodejs的这个问题，我按照前人的提示选择了async的框架</p>

<p>其实这个框架里我更多的是使用async的auto方法
因为这个方法可以并行，串行，按照我写的规则去执行一些异步方法。</p>

<p>比如可以这样
async.auto({
     task1:function(cb, paramData){
     },
     task2:function(cb, paramData){
     },
     task3:[&lsquo;task1&rsquo;,&lsquo;task2&rsquo;,function(cb, paramData){
     }
     task4:[&lsquo;task3&rsquo;,function(cb, paramData){
     }
},function(err, result){
});</p>
-->

  <!--<div class="more">
    <a href="/2013/08/12/how_to_use_async_in_nodejs.html" class="btn">read more..</a>
  </div>-->
</div>

<div class="post">
  <!--<h4 class="title"><a href="/2013/08/12/core_data.html">Core Data</a> <span class="date">2013-07-11</span></h3>-->
  <h4 class="title"><a href="/2013/08/12/core_data.html">Core Data</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;core data</p>
  <!--<h1>Core Data</h1>

<p>1: Core Data
数据库操作当有insert操作做merge通知的时候会立即触发processPendingChange，但是如果没有insert，而只有delete和update的时候，则只会投放一个processPendingChange但不会立即执行，所以当一个save先update然后delete的时候，merge就出问题了。</p>

<p>工作：
今天依然是对首页等地方进行性能调优
改善的点是
1：计算时间，格式化显示的时候，ios相对比较耗时，此时如果对性能有一定要求的话，还是考虑用c的api实现一把，另外stringWithFormat在对性能有一定要求的地方也应该尽量考虑用C函数拼接好后再一次搞定。
经过函数的重写，该函数性能提升2.4倍</p>

<p>2：core data数据库fetch的时候，如果你只为了查询一个对象，而且这个对象之前已经在当前contxt上的话，那么fetch操作依然是一个耗时的操作，原因应该是由于core data没有暴露出来的key，那么你查询数据库中的条件理论上查询出来的都是一个数组，而且及时表是一个空表，core data的一次fetch依然会尝试查询数据库一把。也就造成了性能的直接下降。
但是据说如果你是用了objectid去查询的话就快一些，因为你的对象已经在内存中了，并且一个managedObject有个fault属性，如果你查询的objectId对应的对象的fault属性不是true的话，你的查询应该就不会倒数据库里在查询呢一次。</p>

<p>3：个人感觉如果需要使用core data，应该尽可能的不要直接完全依然coredata的managedObject对象，一是可以一定程度解耦，不然一旦更换core data的机制，你就代码里也改动很大了。</p>

<p>4：c函数里（t m） 结构体和和time_t可以通过mktime，gmtime和localtime去互相转化，注意localtime是当地时区的时间。获取的time_t都是从1970年开始到现在的时间。另外注意的是t m里tm_mon是从0开始算起的月份，所以正常情况下你需要进行+1处理表示正常的月份。
另外注意如果是考虑到多线程的话，不要使用localtime，这个是线程不安全的，应该使用localtime_r等接口。
struct tm localNow;
time_t rawtime = (time_t)offsetTimeInterval;
localtime_r(&amp;rawtime, &amp;localNow);
这样就填充好了一个包含年月日时分秒的数据结构了。</p>
-->

  <!--<div class="more">
    <a href="/2013/08/12/core_data.html" class="btn">read more..</a>
  </div>-->
</div>

<div class="post">
  <!--<h4 class="title"><a href="/2013/04/06/more-about-markdown.html">more about markdown</a> <span class="date">2013-06-05</span></h3>-->
  <h4 class="title"><a href="/2013/04/06/more-about-markdown.html">more about markdown</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;more about markdown</p>
  <!--<h1>关于几个之前忽略的markdown的语法</h1>

<ol>
<li>行末连续两个空格然后回车，可以造成文本换行</li>
</ol>

<pre><code>abcdefg“空格空格”
hijklmn
</code></pre>

<p>abcdefg<br />
hijklmn</p>

<ol>
<li><p><a name="md-anchor" id="md-anchor">段落缩进</a></p>

<p>段落缩进演示：
&gt; 第一段
&gt;
&gt;&gt; 第二段
&gt;&gt;&gt; 第三段
&gt;&gt;
&gt;&gt; 第二段</p></li>

<li><p>四个空格缩进是代码块：</p></li>

<li><p>无序列表</p>

<ul>
<li>星号、减号、加号开始列表。

<ul>
<li>列表层级和缩进有关。

<ul>
<li>和具体符号无关。</li>
</ul></li>
</ul></li>
<li>返回一级列表。</li>
</ul></li>
</ol>
-->

  <!--<div class="more">
    <a href="/2013/04/06/more-about-markdown.html" class="btn">read more..</a>
  </div>-->
</div>

<div class="post">
  <!--<h4 class="title"><a href="/2013/05/30/about_nscache.html">涨姿势-NSCache</a> <span class="date">2013-05-30</span></h3>-->
  <h4 class="title"><a href="/2013/05/30/about_nscache.html">涨姿势-NSCache</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;cache数据，与NSMutableDictionary类似的用于不保证cache对象永远存在的一种缓存</p>
  <!--<h1>NSCache</h1>

<p>他的用法很简单，基本等效于NSMutableDictionary，只不过他不保证cache里的对象永远存在，也许在低内存警告时会释放掉部分对象，所以如果你的程序里如果有可以重复创建的对象需要保存时，可以考虑使用这个类。</p>

<p>以下是转载来的。
NSCache 是iOS4以后引入的一个方便的缓存某些object的类。它的使用方法与NSMutableDictionary很相似，但是他会在内存吃紧的时候自动释放某些object。而且不用考虑线程安全的问题。具体的可以参见官方文档的描述。以下是stackoverflow里面一个比较不错的应用例子：</p>

<p>You use it the same way you would use NSMutableDictionary. The difference is that whenNSCache detects excessive memory pressure (i.e. it&rsquo;s caching too many values) it will release some of those values to make room.</p>

<p>If you can recreate those values at runtime (by downloading from the Internet, by doing calculations, whatever) then NSCache may suit your needs. If the data cannot be recreated (e.g. it&rsquo;s user input, it is time-sensitive, etc.) then you should not store it in an NSCache because it will be destroyed there.</p>

<pre><code>You use it the same way you would use NSMutableDictionary. The difference is that whenNSCache detects excessive memory pressure (i.e. it's caching too many values) it will release some of those values to make room.

If you can recreate those values at runtime (by downloading from the Internet, by doing calculations, whatever) then NSCache may suit your needs. If the data cannot be recreated (e.g. it's user input, it is time-sensitive, etc.) then you should not store it in an NSCache because it will be destroyed there.

Example, not taking thread safety into account:

// Your cache should have a lifetime beyond the method or handful of methods
// that use it. For example, you could make it a field of your application
// delegate, or of your view controller, or something like that. Up to you.
NSCache *myCache = ...;
NSAssert(myCache != nil, @&quot;cache object is missing&quot;);

// Try to get the existing object out of the cache, if it's there.
Widget *myWidget = [myCache objectForKey: @&quot;Important Widget&quot;];
if (!myWidget) {
    // It's not in the cache yet, or has been removed. We have to
    // create it. Presumably, creation is an expensive operation,
    // which is why we cache the results. If creation is cheap, we
    // probably don't need to bother caching it. That's a design
    // decision you'll have to make yourself.
    myWidget = [[[Widget alloc] initExpensively] autorelease];

    // Put it in the cache. It will stay there as long as the OS
    // has room for it. It may be removed at any time, however,
    // at which point we'll have to create it again on next use.
    [myCache setObject: myWidget forKey: @&quot;Important Widget&quot;];
}

// myWidget should exist now either way. Use it here.
if (myWidget) {
    [myWidget runOrWhatever];
}
</code></pre>
-->

  <!--<div class="more">
    <a href="/2013/05/30/about_nscache.html" class="btn">read more..</a>
  </div>-->
</div>

<div class="post">
  <!--<h4 class="title"><a href="/2013/05/30/git_useage_and_github.html">git使用及github</a> <span class="date">2013-05-30</span></h3>-->
  <h4 class="title"><a href="/2013/05/30/git_useage_and_github.html">git使用及github</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;git使用及github的一些说明</p>
  <!--<h1>git使用及github</h1>

<p>git 和github越来越多人使用，作为一个程序员，应该懂的怎么去用，而我就是个不怎么会用的人，所以我的主管在我刚开始上班的时候就要我去熟悉git那套东西。</p>

<p>当时我依然不是很懂，但最近开始迷糊的懂了，下面是我这段时间的心得。</p>

<h2>创建ssh从而能免登访问github。</h2>

<p>命令<code>ssh-keygen</code>去创建公钥私钥，如果你只希望访问一个服务器的话，比如github，那么你就放到默认的目录下，并且使用默认的私钥和公钥文件路径，即~/.ssh/id_rsa和~/.ssh/id_rsa.pub，其中id_rsa.pub是公钥文件。我们需要将这个文件里的数据复制并粘贴到github上的ssh key里。从而通过ssh就可以面等访问github了。</p>

<p>如果你有多个服务器需要访问，比如我们还需要访问gitlab，那么，这个时候，需要~/.ssh/config文件里的配置来区分服务器和ssh秘钥。</p>

<p>比如我自己的配置为</p>

<pre><code>Host github.com
    HostName github.com
    User taoxiaoseng@gmail.com
    IdentityFile /Users/Dick/.ssh/github_taoxiaoseng_rsa
    
Host gitlab.alibaba-inc.com
    HostName gitlab.alibaba-inc.com
    User guodi.ggd@taobao.com
    IdentityFile /Users/Dick/.ssh/gitlab_rsa
</code></pre>
-->

  <!--<div class="more">
    <a href="/2013/05/30/git_useage_and_github.html" class="btn">read more..</a>
  </div>-->
</div>

<div class="post">
  <!--<h4 class="title"><a href="/2013/04/22/Concurrency_with_Core_Data.html">CoreData编程指南_CoreData的并发编程_章节翻译</a> <span class="date">2013-04-22</span></h3>-->
  <h4 class="title"><a href="/2013/04/22/Concurrency_with_Core_Data.html">CoreData编程指南_CoreData的并发编程_章节翻译</a></h4>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;文档生成命令</p>
  <!--<h1>Core Data的并发（Concurrency with Core Data）</h1>

<p>存在着一些的场景，我们需要利用后台线程或者队列来执行Core Data的一些操作，因为他们能我们带来一些好处，尤其是你需要在Core Data在做一些比较消耗时间的任务时能保证应用程序的用户交互界面能及时响应。但是如果你并发使用Core Data时，那么你需要关心，考虑到对象图(object Groups)不会进入一个冲突的状态。</p>

<p>如果你选择使用并发编程来操作Core Data，你还需要考虑到应用程序的环境。对于大多数的情况，AppKit和UIKit是线程不安全的；另外，OS X Cocoa bindings和controllers也都是线程不安全的 &ndash; 如果你正在使用这些技术，多线程就会复杂了。</p>

<h2>使用Thread Confinement来支持并发（Use Thread Confinement to Support Concurrency）</h2>

<p>Core Data推荐的并发编程的模式是thread confinement（线程封闭，线程约束？）：每个线程必须拥有属于它自身的，完全私有的managed object context。</p>

<p>这里有两种可能的方法来采用这种模式：</p>

<ol>
<li>给每个线程创建一个managed object context，并且共享一个persistent store coordinator</li>
<li>给每隔线程创建一个managed object context和persistent store coordinator。（这种方法提供更加强大的并发，但是同样会更加的复杂（尤其是你需要在不同的context之间进行交互）和消耗更多的内存使用）</li>
</ol>

<p>你必须在它使用的线程中创建相应的managed context。如果你使用的NSOperation，你需要注意它的init方法是在被调用（caller）的线程里执行的。所以你不能够在queue的init方法里创建managed object context，否则你创建的context会关联到这个caller调用者的线程。与之相对应的，你应该在main方法（针对serial queue串行队列）或者start方法（针对concurent queue并发队列）里创建context。</p>

<p>使用thread confinement（线程封闭，线程约束？），你不应该在线程间传递managed objects或者managed object contexts。如果你需要跨线程传递一个managed object，你可以通过以下方法:</p>

<ul>
<li>传递它的object ID（objectID）然后在接收线程里的managed object context里使用objectWithID:或者existingObjectWithID:error:去获取。相对应的managed objects必须已经保存（save）&ndash;你不能够传递一个新创建的还没有保存过的managed object的ID给另外一个context上。</li>
<li>在接收context上通过执行fetch来获取得到需要的managed object。</li>
</ul>
-->

  <!--<div class="more">
    <a href="/2013/04/22/Concurrency_with_Core_Data.html" class="btn">read more..</a>
  </div>-->
</div>

<hr/>
<!-- Duoshuo Comment BEGIN -->
	<div class="ds-thread"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"taoxiaoseng"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- Duoshuo Comment END -->
  </div>
</div>

      </div>

      <footer>
        <p>&copy; taoxiaoseng 2013 
          with help from <a href="http://github.com/wendal/gor" target="_blank" title="Gor -- Fast Blog">Gor</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
		  and Idea from <a href="http://ruhoh.com" target="_blank" title="The Definitive Technical Blogging Framework">ruhoh</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
<script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/188.0.0/prettify.js"></script>
<script>
  var pres = document.getElementsByTagName("pre");
  for (var i=0; i < pres.length; ++i) {
    pres[i].className = "prettyprint linenums";
  }
  prettyPrint();
</script>

    
<script>
    var _gaq=[['_setAccount','UA-123-12'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
  </body>
</html>
